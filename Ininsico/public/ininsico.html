<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Olmec 3D - Professional Modeling Suite</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/three-js-csg@1.0.0/ThreeCSG.js"></script>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/GLTFExporter.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/TransformControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three-csg-ts@1.0.3/dist/three-csg.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tween.js@18.5.0/dist/tween.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dat.gui@0.7.7/build/dat.gui.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&family=JetBrains+Mono:wght@400;500;600&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --primary: #6e48ff;
            /* Vibrant purple-blue */
            --primary-dark: #4a1eff;
            /* Darker purple-blue */
            --secondary: #9d50ff;
            /* Lighter purple */
            --accent: #4776ff;
            /* Blue accent */
            --bg-primary: #0a0a0a;
            --bg-secondary: #111111;
            --bg-tertiary: #1a1a1a;
            --glass: rgba(255, 255, 255, 0.05);
            --glass-border: rgba(255, 255, 255, 0.1);
            --success: #4a68de;
            --warning: #fbbf24;
            --error: #ff4d4d;
            --info: #60a5fa;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Inter', sans-serif;
        }

        body {
            background: linear-gradient(135deg, #0a0a0a 0%, #111111 50%, #0f0f23 100%);
            overflow: hidden;
            color: #ffffff;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background:
                radial-gradient(circle at 20% 80%, rgba(110, 72, 255, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(157, 80, 255, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, rgba(71, 118, 255, 0.05) 0%, transparent 50%);
            pointer-events: none;
            z-index: -1;
        }

        /* Improved Glass Effect */
        .glass {
            background: rgba(20, 20, 20, 0.4);
            backdrop-filter: blur(16px) saturate(180%);
            border: 1px solid rgba(255, 255, 255, 0.08);
            transition: all 0.3s ease;
        }

        .submenu {
            position: absolute;
            top: 100%;
            left: 0;
            min-width: 200px;
            background: rgba(20, 20, 20, 0.95);
            backdrop-filter: blur(16px) saturate(180%);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            opacity: 0;
            visibility: hidden;
            transform: translateY(10px);
            transition: all 0.3s ease;
            z-index: 100;
        }


        .menu-item:hover .submenu {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .glass:hover {
            background: rgba(30, 30, 30, 0.5);
            border-color: rgba(255, 255, 255, 0.15);
        }

        .glass-dark {
            background: rgba(10, 10, 10, 0.5);
            backdrop-filter: blur(16px) saturate(180%);
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        /* Neon Effects */
        .neon-border {
            border: 1px solid var(--primary);
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
        }

        .neon-glow {
            box-shadow:
                0 0 20px rgba(110, 72, 255, 0.2),
                0 0 40px rgba(110, 72, 255, 0.1),
                inset 0 0 20px rgba(110, 72, 255, 0.05);
        }

        /* Animation Timeline Styles */
        /* In your style section */
        .animation-timeline {
            height: 120px;
            min-height: 120px;
            max-height: 50vh;
            resize: vertical;
            overflow: hidden;
        }

        .timeline-grid {
            flex: 1;
            min-width: 0;
            overflow: auto;
            background-image:
                linear-gradient(rgba(255, 255, 255, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.1) 1px, transparent 1px);
            background-position-y: 24px;
        }

        .frame-numbers {
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .frame-numbers>div {
            width: 40px;
            text-align: center;
            font-size: 10px;
            color: rgba(255, 255, 255, 0.5);
            border-right: 1px solid rgba(255, 255, 255, 0.05);
        }

        .track-item {
            width: 160px;
            /* Fixed width */
            flex-shrink: 0;
            cursor: pointer;
            transition: background 0.2s;
        }

        .track-item:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .track {
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .keyframe {
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            z-index: 5;
        }

        .keyframe:hover {
            transform: scale(1.3);
            box-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
        }

        .keyframe.selected {
            transform: scale(1.3);
            box-shadow: 0 0 5px var(--primary);
        }

        .keyframe.location {
            background: #4d9eff;
        }

        .keyframe.rotation {
            background: #ff9e4d;
        }

        .keyframe.scale {
            background: #4dff9e;
        }

        .keyframe.visibility {
            background: #ff4d9e;
        }

        .track-property {
            padding-left: 20px;
            font-size: 11px;
            color: rgba(255, 255, 255, 0.7);
        }

        .track-property .keyframe {
            width: 8px;
            height: 8px;
            margin-top: -4px;
        }

        /* Animation curve editor (for later implementation) */
        .curve-editor {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 100px;
            background: rgba(20, 20, 20, 0.9);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            display: none;
        }

        .curve-editor.active {
            display: block;
        }

        /* Dope sheet view (for later implementation) */
        .dopesheet-view .track {
            height: 24px;
        }

        .dopesheet-view .keyframe {
            width: 6px;
            height: 6px;
            margin-top: -3px;
        }

        /* Main container */
        #app {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        /* Content area */
        .main-content {
            flex: 1;
            min-height: 0;
            /* Allow shrinking */
            display: flex;
            overflow: hidden;
        }

        /* Viewport area */
        .viewport-container {
            flex: 1;
            min-width: 0;
            /* Allow shrinking */
            display: flex;
            flex-direction: column;
        }

        /* Animations */
        @keyframes float {

            0%,
            100% {
                transform: translateY(0px);
            }

            50% {
                transform: translateY(-10px);
            }
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: .8;
            }
        }

        @keyframes slideInLeft {
            from {
                transform: translateX(-100%);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes pulse-glow {

            0%,
            100% {
                box-shadow: 0 0 10px rgba(110, 72, 255, 0.5);
            }

            50% {
                box-shadow: 0 0 20px rgba(110, 72, 255, 0.8);
            }
        }

        @keyframes tool-hover {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.1);
            }

            100% {
                transform: scale(1);
            }
        }

        /* Buttons */
        .btn-primary {
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            box-shadow: 0 4px 15px rgba(58, 134, 255, 0.3);
            transition: all 0.3s ease;
            border: none;
            color: white;
            font-weight: 600;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 255, 0.4);
            animation: pulse-glow 1.5s infinite;
        }

        .btn-secondary {
            background: linear-gradient(135deg, var(--secondary) 0%, #6a2fc6 100%);
            box-shadow: 0 4px 15px rgba(131, 56, 236, 0.3);
            transition: all 0.3s ease;
            border: none;
            color: white;
            font-weight: 600;
        }

        .btn-secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(139, 92, 246, 0.4);
            animation: pulse-glow 1.5s infinite;
        }

        /* Logo */
        .logo {
            font-family: 'JetBrains Mono', monospace;
            font-weight: 800;

            background: linear-gradient(135deg, var(--primary) 0%, var(--accent) 100%);

            transition: all 0.3s ease;
        }

        .logo:hover {
            filter: drop-shadow(0 0 15px rgba(110, 72, 255, 0.8));
        }

        /* Menu Items */
        .menu-item {
            position: relative;
            overflow: visible;
            transition: all 0.2s ease;
            pointer-events: auto;
        }

        .menu-item:hover {
            background: rgba(255, 255, 255, 0.05);
            pointer-events: auto;
        }

        @media (max-width: 1024px) {
            .animation-timeline {
                height: 100px;
            }

            .track-names {
                width: 120px;
            }
        }

        @media (max-width: 768px) {
            .animation-timeline {
                height: 80px;
                font-size: 0.9em;
            }

            .track-names {
                width: 100px;
            }
        }

        /* Axis constraint buttons */
        .axis-constraint-btn {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.7);
        }

        .axis-constraint-btn.active {
            background: var(--primary);
            color: #111;
        }

        .axis-constraint-btn[data-axis="x"].active {
            background: #ff4d4d;
        }

        .axis-constraint-btn[data-axis="y"].active {
            background: #4dff4d;
        }

        .axis-constraint-btn[data-axis="z"].active {
            background: #4d4dff;
        }

        /* Texture buttons */
        .texture-btn {
            transition: all 0.2s ease;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .texture-btn:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        /* Notification types */
        .notification.info {
            border-left: 4px solid var(--secondary);
        }

        .notification.success {
            border-left: 4px solid var(--success);
        }

        .notification.warning {
            border-left: 4px solid var(--warning);
        }

        .notification.error {
            border-left: 4px solid #ff4d4d;
        }

        /* Collapsible Panel Styles */
        .panel-toggle {
            position: absolute;
            top: 50%;
            width: 16px;
            height: 48px;
            background: rgba(30, 30, 30, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 10;
            transition: all 0.3s ease;
            border-radius: 4px;
        }

        .panel-toggle:hover {
            background: rgba(60, 60, 60, 0.8);
        }

        .left-panel-toggle {
            right: -16px;
            transform: translateY(-50%);
            border-left: none;
            border-radius: 0 4px 4px 0;
        }

        .right-panel-toggle {
            left: -16px;
            transform: translateY(-50%);
            border-right: none;
            border-radius: 4px 0 0 4px;
        }

        .collapsed {
            width: 0 !important;
            overflow: hidden;
            border: none;
        }

        .collapsed .panel-content {
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .panel-content {
            transition: opacity 0.3s ease;
        }

        /* Tool Buttons */
        .tool-btn {
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .tool-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            animation: tool-hover 0.5s ease;
        }

        /* Update status bar */
        .status-bar {
            border-top: 1px solid rgba(110, 72, 255, 0.3);
        }

        /* Inputs */
        .property-input {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
            color: white;
        }

        .property-input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 10px rgba(51, 0, 255, 0.3);
            outline: none;
        }

        /* Scrollbar */
        .scrollbar::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        .scrollbar::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
        }

        .scrollbar::-webkit-scrollbar-thumb {
            background: rgba(110, 72, 255, 0.3);
            border-radius: 3px;
        }

        .scrollbar::-webkit-scrollbar-thumb:hover {
            background: rgba(110, 72, 255, 0.5);
        }

        /* Viewport */
        .viewport {
            background: radial-gradient(ellipse at center, #1a1a1a 0%, #0a0a0a 100%);
            position: relative;
        }

        /* Welcome Screen */
        .welcome-screen {
            background: rgba(10, 10, 10, 0.7);
            backdrop-filter: blur(10px);
            transition: all 0.5s ease;
        }

        .hidden {
            display: none !important;
        }

        /* Add this to make the timeline resizable */
        .animation-timeline {
            transition: height 0.3s ease;
        }

        /* Sculpting Tools */
        .sculpt-tool {
            transition: all 0.3s ease;
            border-radius: 8px;
            padding: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
        }

        /* Update active tool buttons */
        .tool-btn.active {
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%) !important;
            box-shadow: 0 0 20px rgba(110, 72, 255, 0.5) !important;
        }

        /* Improved Panel Headers */
        .panel-header {
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.5) 0%, rgba(17, 17, 17, 0.5) 100%);
            border-bottom: 1px solid rgba(110, 72, 255, 0.3);
            padding: 12px 16px;
            border-radius: 8px 8px 0 0;
            transition: all 0.3s ease;
        }

        .panel-header:hover {
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.7) 0%, rgba(17, 17, 17, 0.7) 100%);
        }

        /* Three.js canvas styling */
        #three-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            outline: none;
        }

        /* Context Menu */
        .context-menu {
            background: rgba(20, 20, 20, 0.95);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(110, 72, 255, 0.3);
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            min-width: 200px;
            z-index: 1000;
            transform-origin: top left;
            animation: fadeIn 0.2s ease-out;
        }

        .context-item {
            transition: all 0.2s ease;
        }

        .context-item:hover {
            background: rgba(0, 255, 136, 0.1);
        }


        /* Tab System */
        .tab-button {
            padding: 8px 16px;
            background: rgba(255, 255, 255, 0.05);
            border: none;
            color: rgba(255, 255, 255, 0.7);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .tab-button:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .tab-button.active {
            background: rgba(252, 251, 255, 0.2);
            color: white;
            border-bottom: 2px solid var(--primary);
        }

        /* Toolbar */
        .toolbar-section {
            display: flex;
            align-items: center;
            padding: 0 12px;
            border-right: 1px solid rgba(255, 255, 255, 0.05);
        }

        /* Update scene items */
        .scene-item:hover {
            background: rgba(110, 72, 255, 0.1);
        }

        .scene-item.selected {
            background: rgba(110, 72, 255, 0.2);
            border-left: 3px solid var(--primary);
        }

        .scene-item.selected {
            background: rgba(0, 255, 136, 0.2);
            border-left: 3px solid var(--primary);
        }

        /* Sculpting Panel */
        .sculpting-panel {
            display: none;
        }

        /* Update sculpt tools */
        .sculpt-tool:hover {
            background: rgba(110, 72, 255, 0.1);
        }

        .sculpt-tool.active {
            background: rgba(110, 72, 255, 0.2);
            border: 1px solid var(--primary);
            box-shadow: 0 0 15px rgba(110, 72, 255, 0.3);
        }

        /* Animation Classes */
        .floating-animation {
            animation: float 3s ease-in-out infinite;
        }

        .pulse-animation {
            animation: pulse 2s ease infinite;
        }

        .slide-in-left {
            animation: slideInLeft 0.5s ease-out;
        }

        .slide-in-right {
            animation: slideInRight 0.5s ease-out;
        }

        .fade-in {
            animation: fadeIn 0.3s ease-out;
        }

        /* Responsive Adjustments */
        @media (max-width: 1200px) {
            .sidebar {
                width: 280px;
            }
        }

        /* Custom Grid */
        .grid-pattern {
            background-image:
                linear-gradient(rgba(255, 255, 255, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.1) 1px, transparent 1px);
            background-size: 20px 20px;
        }

        /* Add to your styles */
        #sculpt-mode-indicator {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(110, 72, 255, 0.3);
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            display: none;
            z-index: 100;
        }

        /* Tooltip */
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 100;
        }

        /* Progress Bar */
        .progress-bar {
            height: 4px;
            background: var(--primary);
            width: 0%;
            transition: width 0.3s ease;
        }

        /* Notification */
        .notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 8px;
            transform: translateY(100px);
            opacity: 0;
            transition: all 0.3s ease;
            z-index: 1000;
        }

        .notification.show {
            transform: translateY(0);
            opacity: 1;
        }
    </style>
</head>

<body>
    <div id="app" class="h-screen flex flex-col">
        <!-- Header -->
        <header class="h-16 glass-dark border-b border-gray-800/50 flex items-center px-6 relative z-50 slide-in-left">
            <div class="text-2xl font-black mr-8 ">
                Olmec
            </div>

            <nav class="flex space-x-1">
                <div class="menu-item relative group">
                    <div class="px-4 py-2 rounded-lg cursor-pointer">
                        <span class="text-sm font-medium">File</span>
                    </div>
                    <div
                        class="submenu absolute top-full left-0 mt-2 min-w-[200px] rounded-lg opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all duration-300 transform translate-y-2 group-hover:translate-y-0 glass-dark">
                        <div class="submenu-item px-4 py-3 text-sm cursor-pointer rounded-t-lg" id="new-project-btn">
                            <i class="fas fa-plus w-4 mr-3"></i>New Project
                        </div>
                        <div class="submenu-item px-4 py-3 text-sm cursor-pointer" id="open-project-btn">
                            <i class="fas fa-folder-open w-4 mr-3"></i>Open...
                        </div>
                        <div class="h-px bg-gray-700 mx-2"></div>
                        <div class="submenu-item px-4 py-3 text-sm cursor-pointer" id="import-btn">
                            <i class="fas fa-download w-4 mr-3"></i>Import
                        </div>
                        <div class="submenu-item px-4 py-3 text-sm cursor-pointer rounded-b-lg" id="export-btn">
                            <i class="fas fa-upload w-4 mr-3"></i>Export
                        </div>
                    </div>
                </div>

                <div class="menu-item relative group">
                    <div class="px-4 py-2 rounded-lg cursor-pointer">
                        <span class="text-sm font-medium">Edit</span>
                    </div>
                    <div
                        class="submenu absolute top-full left-0 mt-2 min-w-[200px] rounded-lg opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all duration-300 transform translate-y-2 group-hover:translate-y-0 glass-dark">
                        <div class="submenu-item px-4 py-3 text-sm cursor-pointer rounded-t-lg" id="undo-btn">
                            <i class="fas fa-undo w-4 mr-3"></i>Undo
                        </div>
                        <div class="submenu-item px-4 py-3 text-sm cursor-pointer" id="redo-btn">
                            <i class="fas fa-redo w-4 mr-3"></i>Redo
                        </div>
                        <div class="h-px bg-gray-700 mx-2"></div>
                        <div class="submenu-item px-4 py-3 text-sm cursor-pointer" id="duplicate-btn">
                            <i class="fas fa-clone w-4 mr-3"></i>Duplicate
                        </div>
                        <div class="submenu-item px-4 py-3 text-sm cursor-pointer rounded-b-lg" id="delete-btn">
                            <i class="fas fa-trash w-4 mr-3"></i>Delete
                        </div>
                    </div>
                </div>

                <div class="menu-item relative group">
                    <div class="px-4 py-2 rounded-lg cursor-pointer">
                        <span class="text-sm font-medium">Add</span>
                    </div>
                    <div
                        class="submenu absolute top-full left-0 mt-2 min-w-[200px] rounded-lg opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all duration-300 transform translate-y-2 group-hover:translate-y-0 glass-dark">
                        <div class="submenu-item px-4 py-3 text-sm cursor-pointer rounded-t-lg" id="add-mesh-btn">
                            <i class="fas fa-cube w-4 mr-3"></i>Mesh
                        </div>
                        <div class="submenu-item px-4 py-3 text-sm cursor-pointer" id="add-light-btn">
                            <i class="fas fa-lightbulb w-4 mr-3"></i>Light
                        </div>
                        <div class="submenu-item px-4 py-3 text-sm cursor-pointer rounded-b-lg" id="add-camera-btn">
                            <i class="fas fa-camera w-4 mr-3"></i>Camera
                        </div>
                    </div>
                </div>

                <div class="menu-item relative group">
                    <div class="px-4 py-2 rounded-lg cursor-pointer">
                        <span class="text-sm font-medium">Sculpt</span>
                    </div>
                    <div
                        class="submenu absolute top-full left-0 mt-2 min-w-[200px] rounded-lg opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all duration-300 transform translate-y-2 group-hover:translate-y-0 glass-dark">
                        <div class="submenu-item px-4 py-3 text-sm cursor-pointer rounded-t-lg" id="sculpt-draw-btn">
                            <i class="fas fa-paint-brush w-4 mr-3"></i>Draw
                        </div>
                        <div class="submenu-item px-4 py-3 text-sm cursor-pointer" id="sculpt-smooth-btn">
                            <i class="fas fa-hand-holding-water w-4 mr-3"></i>Smooth
                        </div>
                        <div class="submenu-item px-4 py-3 text-sm cursor-pointer" id="sculpt-flatten-btn">
                            <i class="fas fa-ruler-combined w-4 mr-3"></i>Flatten
                        </div>
                        <div class="submenu-item px-4 py-3 text-sm cursor-pointer rounded-b-lg" id="sculpt-inflate-btn">
                            <i class="fas fa-expand w-4 mr-3"></i>Inflate
                        </div>
                    </div>
                </div>
                <div class="menu-item relative group">
                    <div class="px-4 py-2 rounded-lg cursor-pointer">
                        <span class="text-sm font-medium">Timeline</span>
                    </div>
                </div>
            </nav>

            <div class="ml-auto flex items-center space-x-4">
                <div class="flex items-center space-x-2">
                    <div class="w-2 h-2 bg-primary-400 rounded-full pulse-animation"></div>
                    <span class="text-sm text-gray-400 code-font">ONLINE</span>
                </div>
                <button class="btn-primary px-4 py-2 rounded-lg text-sm font-medium" id="export-scene-btn">
                    <i class="fas fa-cloud-upload-alt mr-2"></i>Export
                </button>
                <button class="btn-secondary px-4 py-2 rounded-lg text-sm font-medium" id="toggle-timeline-btn">
                    <i class="fas fa-film mr-2"></i>Timeline
                </button>
            </div>

        </header>

        <!-- Progress Bar -->
        <div class="progress-bar" id="progress-bar"></div>

        <!-- Main Container -->
        <div class="flex-1 flex overflow-hidden">
            <!-- Left Sidebar -->
            <aside class="w-80 glass-dark border-r border-gray-800/50 overflow-y-auto scrollbar slide-in-left relative">
                <!-- Add toggle button -->
                <div class="panel-toggle left-panel-toggle" id="left-panel-toggle">
                    <i class="fas fa-chevron-left"></i>
                </div>
                <div class="panel-content h-full">
                    <!-- Tab Navigation -->
                    <div class="flex border-bv  border-gray-800/50">
                        <button class="tab-button active" data-tab="create">Create</button>
                        <button class="tab-button" data-tab="sculpt">Sculpt</button>
                        <button class="tab-button" data-tab="scene">Scene</button>
                    </div>

                    <!-- Create Panel -->
                    <div class="p-6 fade-in" id="create-panel">
                        <div class="panel-header">
                            <h3 class="font-semibold text-lg flex items-center">
                                <i class="fas fa-plus-circle mr-3 text-green-400"></i>
                                Create Objects
                            </h3>
                        </div>
                        <div class="p-4 bg-black/20 rounded-b-lg">
                            <div class="grid grid-cols-3 gap-3">
                                <div class="create-shape glass rounded-lg p-4 cursor-pointer flex flex-col items-center space-y-2"
                                    data-shape="box">
                                    <i class="fas fa-cube text-2xl text-green-400"></i>
                                    <span class="text-xs font-medium">Cube</span>
                                </div>
                                <div class="create-shape glass rounded-lg p-4 cursor-pointer flex flex-col items-center space-y-2"
                                    data-shape="sphere">
                                    <i class="fas fa-globe text-2xl text-blue-400"></i>
                                    <span class="text-xs font-medium">Sphere</span>
                                </div>
                                <div class="create-shape glass rounded-lg p-4 cursor-pointer flex flex-col items-center space-y-2"
                                    data-shape="cylinder">
                                    <i class="fas fa-database text-2xl text-purple-400"></i>
                                    <span class="text-xs font-medium">Cylinder</span>
                                </div>
                                <div class="create-shape glass rounded-lg p-4 cursor-pointer flex flex-col items-center space-y-2"
                                    data-shape="cone">
                                    <i class="fas fa-concierge-bell text-2xl text-yellow-400"></i>
                                    <span class="text-xs font-medium">Cone</span>
                                </div>
                                <div class="create-shape glass rounded-lg p-4 cursor-pointer flex flex-col items-center space-y-2"
                                    data-shape="torus">
                                    <i class="fas fa-ring text-2xl text-pink-400"></i>
                                    <span class="text-xs font-medium">Torus</span>
                                </div>
                                <div class="create-shape glass rounded-lg p-4 cursor-pointer flex flex-col items-center space-y-2"
                                    data-shape="plane">
                                    <i class="fas fa-square text-2xl text-gray-400"></i>
                                    <span class="text-xs font-medium">Plane</span>
                                </div>
                                <div class="create-shape glass rounded-lg p-4 cursor-pointer flex flex-col items-center space-y-2"
                                    data-shape="extrude">
                                    <i class="fas fa-vector-square text-2xl text-blue-400"></i>
                                    <span class="text-xs font-medium">Extrude</span>
                                </div>
                                <div class="create-shape glass rounded-lg p-4 cursor-pointer flex flex-col items-center space-y-2"
                                    data-shape="bevel">
                                    <i class="fas fa-border-style text-2xl text-purple-400"></i>
                                    <span class="text-xs font-medium">Bevel</span>
                                </div>
                                <div class="create-shape glass rounded-lg p-4 cursor-pointer flex flex-col items-center space-y-2"
                                    data-shape="boolean">
                                    <i class="fas fa-shapes text-2xl text-yellow-400"></i>
                                    <span class="text-xs font-medium">Boolean</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Sculpting Panel -->
                    <!-- Update in the HTML -->
                    <div class="p-6 fade-in sculpting-panel" id="sculpt-panel">
                        <div class="panel-header">
                            <h3 class="font-semibold text-lg flex items-center">
                                <i class="fas fa-sculpture mr-3 text-purple-400"></i>
                                Sculpting Tools
                            </h3>
                        </div>
                        <div class="p-4 bg-black/20 rounded-b-lg">
                            <div class="grid grid-cols-4 gap-2 mb-4">
                                <!-- Updated tool buttons with better icons -->
                                <div class="sculpt-tool" data-tool="draw" title="Draw">
                                    <i class="fas fa-paint-brush text-xl text-green-400 mb-1"></i>
                                    <span class="text-xs">Draw</span>
                                </div>
                                <div class="sculpt-tool" data-tool="smooth" title="Smooth">
                                    <i class="fas fa-brush text-xl text-blue-400 mb-1"></i>
                                    <span class="text-xs">Smooth</span>
                                </div>
                                <div class="sculpt-tool" data-tool="flatten" title="Flatten">
                                    <i class="fas fa-ruler-combined text-xl text-yellow-400 mb-1"></i>
                                    <span class="text-xs">Flatten</span>
                                </div>
                                <div class="sculpt-tool" data-tool="inflate" title="Inflate">
                                    <i class="fas fa-expand text-xl text-pink-400 mb-1"></i>
                                    <span class="text-xs">Inflate</span>
                                </div>
                                <div class="sculpt-tool" data-tool="pinch" title="Pinch">
                                    <i class="fas fa-hand-paper text-xl text-red-400 mb-1"></i>
                                    <span class="text-xs">Pinch</span>
                                </div>
                                <div class="sculpt-tool" data-tool="grab" title="Grab">
                                    <i class="fas fa-hand-rock text-xl text-purple-400 mb-1"></i>
                                    <span class="text-xs">Grab</span>
                                </div>
                                <div class="sculpt-tool" data-tool="crevice" title="Crevice">
                                    <i class="fas fa-mountain text-xl text-orange-400 mb-1"></i>
                                    <span class="text-xs">Crevice</span>
                                </div>
                                <div class="sculpt-tool" data-tool="mask" title="Mask">
                                    <i class="fas fa-mask text-xl text-teal-400 mb-1"></i>
                                    <span class="text-xs">Mask</span>
                                </div>
                            </div>

                            <div class="space-y-4">
                                <div>
                                    <label class="block text-xs text-gray-400 mb-1">Brush Size</label>
                                    <div class="flex items-center space-x-2">
                                        <input type="range" min="0.01" max="2" step="0.01" value="0.5" class="w-full"
                                            id="brush-size">
                                        <span class="text-xs w-12 text-right" id="brush-size-value">0.5</span>
                                    </div>
                                </div>

                                <div>
                                    <label class="block text-xs text-gray-400 mb-1">Strength</label>
                                    <div class="flex items-center space-x-2">
                                        <input type="range" min="0.01" max="1" step="0.01" value="0.5" class="w-full"
                                            id="brush-strength">
                                        <span class="text-xs w-12 text-right" id="brush-strength-value">0.5</span>
                                    </div>
                                </div>

                                <div>
                                    <label class="block text-xs text-gray-400 mb-1">Falloff</label>
                                    <div class="flex items-center space-x-2">
                                        <input type="range" min="0" max="1" step="0.01" value="0.5" class="w-full"
                                            id="brush-falloff">
                                        <span class="text-xs w-12 text-right" id="brush-falloff-value">0.5</span>
                                    </div>
                                </div>

                                <div>
                                    <label class="block text-xs text-gray-400 mb-1">Symmetry</label>
                                    <select class="property-input w-full px-3 py-2 rounded-lg text-sm"
                                        id="brush-symmetry">
                                        <option value="none">None</option>
                                        <option value="x">X-Axis</option>
                                        <option value="y">Y-Axis</option>
                                        <option value="z">Z-Axis</option>
                                        <option value="radial">Radial</option>
                                    </select>
                                </div>

                                <div class="flex space-x-2">
                                    <button class="flex-1 btn-secondary py-2 rounded-lg text-sm" id="sculpt-undo-btn">
                                        <i class="fas fa-undo mr-1"></i> Undo
                                    </button>
                                    <button class="flex-1 btn-secondary py-2 rounded-lg text-sm" id="sculpt-redo-btn">
                                        <i class="fas fa-redo mr-1"></i> Redo
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Scene Hierarchy Panel -->
                    <div class="p-6 fade-in sculpting-panel" id="scene-panel">
                        <div class="panel-header">
                            <h3 class="font-semibold text-lg flex items-center">
                                <i class="fas fa-sitemap mr-3 text-blue-400"></i>
                                Scene Hierarchy
                            </h3>
                        </div>
                        <div class="p-4 bg-black/20 rounded-b-lg min-h-[200px]">
                            <ul id="scene-hierarchy" class="space-y-1"></ul>
                            <div class="text-center text-gray-500 text-sm mt-8" id="empty-scene-message">
                                <i class="fas fa-layer-group text-2xl mb-2 block"></i>
                                No objects in scene
                            </div>
                        </div>
                    </div>
                </div>

            </aside>

            <!-- Main Viewport -->
            <main class="flex-1 flex flex-col">
                <!-- Toolbar -->
                <div
                    class="h-16 glass-dark border-b border-gray-800/50 flex items-center px-6 space-x-2 slide-in-right">
                    <div class="toolbar-section">
                        <button class="tool-btn w-10 h-10 rounded-lg flex items-center justify-center text-lg"
                            data-tool="select" id="select-tool-btn">
                            <i class="fas fa-mouse-pointer"></i>
                        </button>
                        <button class="tool-btn w-10 h-10 rounded-lg flex items-center justify-center text-lg"
                            data-tool="move" id="translate-tool-btn">
                            <i class="fas fa-arrows-alt"></i>
                        </button>
                        <button class="tool-btn w-10 h-10 rounded-lg flex items-center justify-center text-lg"
                            data-tool="rotate" id="rotate-tool-btn">
                            <i class="fas fa-sync-alt"></i>
                        </button>
                        <button class="tool-btn w-10 h-10 rounded-lg flex items-center justify-center text-lg"
                            data-tool="scale" id="scale-tool-btn">
                            <i class="fas fa-expand-arrows-alt"></i>
                        </button>
                        <button class="tool-btn w-10 h-10 rounded-lg flex items-center justify-center text-lg"
                            data-tool="boolean-union" id="boolean-union-btn">
                            <i class="fas fa-plus-circle"></i>
                        </button>
                        <button class="tool-btn w-10 h-10 rounded-lg flex items-center justify-center text-lg"
                            data-tool="boolean-difference" id="boolean-difference-btn">
                            <i class="fas fa-minus-circle"></i>
                        </button>
                        <button class="tool-btn w-10 h-10 rounded-lg flex items-center justify-center text-lg"
                            data-tool="boolean-intersect" id="boolean-intersect-btn">
                            <i class="fas fa-times-circle"></i>
                        </button>
                    </div>

                    <div class="toolbar-section">
                        <button class="tool-btn w-10 h-10 rounded-lg flex items-center justify-center text-lg"
                            data-view-mode="solid" id="solid-view-btn">
                            <i class="fas fa-cube"></i>
                        </button>
                        <button class="tool-btn w-10 h-10 rounded-lg flex items-center justify-center text-lg"
                            data-view-mode="wireframe" id="wireframe-view-btn">
                            <i class="fas fa-project-diagram"></i>
                        </button>
                        <button class="tool-btn w-10 h-10 rounded-lg flex items-center justify-center text-lg"
                            data-view-mode="material" id="material-view-btn">
                            <i class="fas fa-palette"></i>
                        </button>
                        <button class="tool-btn w-10 h-10 rounded-lg flex items-center justify-center text-lg"
                            data-view-mode="rendered" id="rendered-view-btn">
                            <i class="fas fa-eye"></i>
                        </button>
                    </div>

                    <div class="toolbar-section">
                        <button class="tool-btn w-10 h-10 rounded-lg flex items-center justify-center text-lg"
                            data-camera-view="front" id="front-view-btn">
                            <i class="fas fa-arrow-up"></i>
                        </button>
                        <button class="tool-btn w-10 h-10 rounded-lg flex items-center justify-center text-lg"
                            data-camera-view="side" id="side-view-btn">
                            <i class="fas fa-arrow-right"></i>
                        </button>
                        <button class="tool-btn w-10 h-10 rounded-lg flex items-center justify-center text-lg"
                            data-camera-view="top" id="top-view-btn">
                            <i class="fas fa-arrow-down"></i>
                        </button>
                        <button class="tool-btn w-10 h-10 rounded-lg flex items-center justify-center text-lg"
                            data-camera-view="perspective" id="perspective-view-btn">
                            <i class="fas fa-cube"></i>
                        </button>
                    </div>

                    <div class="ml-auto flex items-center space-x-4">
                        <div class="flex items-center space-x-2 glass px-4 py-2 rounded-lg">
                            <span class="text-sm text-gray-400">Viewport:</span>
                            <select class="bg-transparent text-sm text-white border-none outline-none"
                                id="viewport-type-select">
                                <option value="perspective">Perspective</option>
                                <option value="orthographic">Orthographic</option>
                            </select>
                        </div>
                    </div>
                </div>

                <!-- 3D Viewport -->
                <div class="flex-1 viewport relative" id="viewport">
                    <canvas id="three-canvas"></canvas>

                    <!-- Welcome screen (hidden when objects exist) -->
                    <div class="absolute inset-0 flex items-center justify-center welcome-screen" id="welcome-screen">
                        <div class="text-center">
                            <div
                                class="w-32 h-32 glass rounded-full flex items-center justify-center mb-8 mx-auto floating-animation">
                                <i class="fas fa-cube text-4xl text-green-400"></i>
                            </div>
                            <h3 class="text-2xl font-bold mb-4">Welcome to Olmec 3D</h3>
                            <p class="text-gray-400 mb-6 max-w-md">Start creating by adding objects from the left panel
                                or use the Add menu above.</p>
                            <div class="flex justify-center space-x-4">
                                <button class="btn-primary px-6 py-3 rounded-lg font-medium" id="add-cube-welcome-btn">
                                    <i class="fas fa-plus mr-2"></i>Add Cube
                                </button>
                                <button class="glass px-6 py-3 rounded-lg font-medium hover:bg-white/10"
                                    id="open-project-welcome-btn">
                                    <i class="fas fa-folder-open mr-2"></i>Open Project
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- Viewport Controls -->
                    <div class="absolute top-4 right-4 flex flex-col space-y-2">
                        <div class="glass rounded-lg p-2" id="axis-helper">
                            <div class="w-16 h-16 relative">
                                <div class="absolute inset-0 border border-gray-600 rounded"></div>
                                <div class="absolute top-1 left-1/2 transform -translate-x-1/2 w-1 h-4 bg-red-400">
                                </div>
                                <div class="absolute right-1 top-1/2 transform -translate-y-1/2 w-4 h-1 bg-primary-400">
                                </div>
                                <div
                                    class="absolute bottom-1 left-1/2 transform -translate-x-1/2 w-3 h-3 border-l border-b border-blue-400">
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Grid Info -->
                    <div class="absolute bottom-4 left-4 glass px-3 py-2 rounded-lg">
                        <span class="text-xs text-gray-400 code-font">Grid: 1.0 units</span>
                    </div>
                </div>
            </main>

            <!-- Right Sidebar -->
            <aside
                class="w-80 glass-dark border-l border-gray-800/50 overflow-y-auto scrollbar slide-in-right relative">

                <!-- Add toggle button -->
                <div class="panel-toggle right-panel-toggle" id="right-panel-toggle">
                    <i class="fas fa-chevron-right"></i>
                </div>
                <!-- Wrap panel content -->
                <div class="panel-content h-full">
                    <!-- Properties Panel -->
                    <!-- Add this to your properties panel section -->
                    <div class="p-6 fade-in" id="bevel-extrude-panel">
                        <div class="panel-header">
                            <h3 class="font-semibold text-lg flex items-center">
                                <i class="fas fa-layer-group mr-3 text-purple-400"></i>
                                Bevel & Extrude
                            </h3>
                        </div>
                        <div class="p-4 bg-black/20 rounded-b-lg">
                            <!-- Extrude Controls -->
                            <div class="mb-4">
                                <label class="block text-xs text-gray-400 mb-2">Extrude Depth</label>
                                <input type="range" min="0.1" max="5" step="0.1" value="1" class="w-full"
                                    id="extrude-depth">
                                <span class="text-xs text-gray-400" id="extrude-depth-value">1.0</span>
                            </div>

                            <!-- Bevel Controls -->
                            <div class="mb-2">
                                <label class="block text-xs text-gray-400 mb-2">Bevel Enabled</label>
                                <input type="checkbox" id="bevel-enabled" class="rounded" checked>
                            </div>

                            <div class="mb-4">
                                <label class="block text-xs text-gray-400 mb-2">Bevel Size</label>
                                <input type="range" min="0" max="1" step="0.05" value="0.1" class="w-full"
                                    id="bevel-size">
                                <span class="text-xs text-gray-400" id="bevel-size-value">0.1</span>
                            </div>

                            <div class="mb-4">
                                <label class="block text-xs text-gray-400 mb-2">Bevel Thickness</label>
                                <input type="range" min="0" max="1" step="0.05" value="0.1" class="w-full"
                                    id="bevel-thickness">
                                <span class="text-xs text-gray-400" id="bevel-thickness-value">0.1</span>
                            </div>

                            <div class="mb-4">
                                <label class="block text-xs text-gray-400 mb-2">Bevel Segments</label>
                                <input type="range" min="1" max="10" step="1" value="3" class="w-full"
                                    id="bevel-segments">
                                <span class="text-xs text-gray-400" id="bevel-segments-value">3</span>
                            </div>

                            <button class="w-full btn-primary px-4 py-2 rounded-lg text-sm font-medium"
                                id="apply-extrude-btn">
                                Apply Extrusion
                            </button>
                        </div>
                    </div>
                    <div class="p-6 fade-in">
                        <div class="panel-header">
                            <h3 class="font-semibold text-lg flex items-center">
                                <i class="fas fa-cog mr-3 text-blue-400"></i>
                                Properties
                            </h3>
                        </div>
                        <div class="p-4 bg-black/20 rounded-b-lg" id="properties-panel">
                            <div class="text-center text-gray-500 text-sm" id="no-selection-message">
                                <i class="fas fa-mouse-pointer text-2xl mb-2 block"></i>
                                Select an object to view properties
                            </div>
                        </div>
                    </div>

                    <!-- Transform Panel -->
                    <div class="p-6 fade-in">
                        <div class="panel-header">
                            <h3 class="font-semibold text-lg flex items-center">
                                <i class="fas fa-arrows-alt mr-3 text-orange-400"></i>
                                Transform
                            </h3>
                        </div>
                        <div class="p-4 bg-black/20 rounded-b-lg">
                            <!-- Transform Tabs -->
                            <div class="flex mb-4">
                                <button class="tab-button active" data-transform-tab="location">Location</button>
                                <button class="tab-button" data-transform-tab="rotation">Rotation</button>
                                <button class="tab-button" data-transform-tab="scale">Scale</button>
                            </div>

                            <!-- Transform Values -->
                            <div class="space-y-3" id="transform-values">
                                <div>
                                    <label class="block text-xs text-gray-400 mb-1">X</label>
                                    <input type="number" value="0.000"
                                        class="property-input w-full px-3 py-2 rounded-lg text-sm code-font"
                                        data-transform-axis="x">
                                </div>
                                <div>
                                    <label class="block text-xs text-gray-400 mb-1">Y</label>
                                    <input type="number" value="0.000"
                                        class="property-input w-full px-3 py-2 rounded-lg text-sm code-font"
                                        data-transform-axis="y">
                                </div>
                                <div>
                                    <label class="block text-xs text-gray-400 mb-1">Z</label>
                                    <input type="number" value="0.000"
                                        class="property-input w-full px-3 py-2 rounded-lg text-sm code-font"
                                        data-transform-axis="z">
                                </div>
                            </div>
                            <div class="flex items-center justify-between mb-3">
                                <span class="text-sm">Snap to Grid</span>
                                <input type="checkbox" id="snap-toggle" class="rounded">
                            </div>
                            <div class="flex items-center justify-between mb-3">
                                <span class="text-sm">Snap Value</span>
                                <input type="number" value="0.25" step="0.05" min="0.05" max="1"
                                    class="property-input w-16 px-2 py-1 rounded text-sm">
                            </div>
                            <div class="flex items-center justify-between mb-3">
                                <span class="text-sm">Axis Constraints</span>
                                <div class="flex space-x-1">
                                    <button class="axis-constraint-btn px-2 py-1 rounded text-xs"
                                        data-axis="x">X</button>
                                    <button class="axis-constraint-btn px-2 py-1 rounded text-xs"
                                        data-axis="y">Y</button>
                                    <button class="axis-constraint-btn px-2 py-1 rounded text-xs"
                                        data-axis="z">Z</button>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Material Panel -->
                    <div class="p-6 fade-in">
                        <div class="panel-header">
                            <h3 class="font-semibold text-lg flex items-center">
                                <i class="fas fa-palette mr-3 text-pink-400"></i>
                                Material
                            </h3>
                            <h3 class="font-semibold text-lg flex items-center">
                                <i class="fas fa-image mr-3 text-teal-400"></i>
                                Texture Maps
                            </h3>
                        </div>
                        <div class="p-4 bg-black/20 rounded-b-lg" id="material-panel">
                            <div class="space-y-4">
                                <div>
                                    <label class="block text-xs text-gray-400 mb-2">Base Color</label>
                                    <div class="flex items-center space-x-2">
                                        <div class="flex items-center space-x-2">
                                            <input type="text" class="property-input" id="color-picker-input">
                                        </div>
                                    </div>
                                </div>
                                <div>
                                    <label class="block text-xs text-gray-400 mb-2">Metallic</label>
                                    <input type="range" min="0" max="1" step="0.01" value="0" class="w-full"
                                        id="metallic-slider">
                                    <span class="text-xs text-gray-400" id="metallic-value">0.00</span>
                                </div>
                                <div>
                                    <label class="block text-xs text-gray-400 mb-2">Roughness</label>
                                    <input type="range" min="0" max="1" step="0.01" value="0.5" class="w-full"
                                        id="roughness-slider">
                                    <span class="text-xs text-gray-400" id="roughness-value">0.50</span>
                                </div>
                                <div>
                                    <label class="block text-xs text-gray-400 mb-2">Diffuse Map</label>
                                    <div class="flex items-center space-x-2">
                                        <button class="texture-btn glass px-3 py-2 rounded-lg text-sm w-full text-left"
                                            id="diffuse-map-btn">
                                            <span id="diffuse-map-name">None</span>
                                        </button>
                                        <button class="glass px-2 py-2 rounded-lg text-sm" id="clear-diffuse-btn">
                                            <i class="fas fa-times"></i>
                                        </button>
                                    </div>
                                </div>
                                <div>
                                    <label class="block text-xs text-gray-400 mb-2">Normal Map</label>
                                    <div class="flex items-center space-x-2">
                                        <button class="texture-btn glass px-3 py-2 rounded-lg text-sm w-full text-left"
                                            id="normal-map-btn">
                                            <span id="normal-map-name">None</span>
                                        </button>
                                        <button class="glass px-2 py-2 rounded-lg text-sm" id="clear-normal-btn">
                                            <i class="fas fa-times"></i>
                                        </button>
                                    </div>
                                </div>
                                <div>
                                    <label class="block text-xs text-gray-400 mb-2">Roughness Map</label>
                                    <div class="flex items-center space-x-2">
                                        <button class="texture-btn glass px-3 py-2 rounded-lg text-sm w-full text-left"
                                            id="roughness-map-btn">
                                            <span id="roughness-map-name">None</span>
                                        </button>
                                        <button class="glass px-2 py-2 rounded-lg text-sm" id="clear-roughness-btn">
                                            <i class="fas fa-times"></i>
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>

                    </div>

                    <!-- Lighting Panel -->
                    <div class="p-6 fade-in">
                        <div class="panel-header">
                            <h3 class="font-semibold text-lg flex items-center">
                                <i class="fas fa-lightbulb mr-3 text-yellow-400"></i>
                                Lighting
                            </h3>
                        </div>
                        <div class="p-4 bg-black/20 rounded-b-lg">
                            <div class="space-y-3">
                                <div class="flex items-center justify-between">
                                    <span class="text-sm">Environment Light</span>
                                    <input type="checkbox" checked class="rounded" id="env-light-toggle">
                                </div>
                                <div>
                                    <label class="block text-xs text-gray-400 mb-2">Intensity</label>
                                    <input type="range" min="0" max="10" step="0.1" value="1" class="w-full"
                                        id="env-light-intensity">
                                </div>
                                <button class="w-full btn-secondary px-4 py-2 rounded-lg text-sm font-medium"
                                    id="add-light-source-btn">
                                    <i class="fas fa-plus mr-2"></i>Add Light Source
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </aside>
        </div>
        <!-- Animation Timeline Panel -->
        <!-- Replace your existing timeline panel with this -->
        <div id="timeline-panel" class="animation-timeline glass-dark border-t border-gray-800/50 h-48 flex flex-col">
            <!-- Timeline Controls -->
            <div class="panel-header flex items-center justify-between px-4 py-2">
                <div class="flex items-center">
                    <i class="fas fa-film mr-2 text-purple-400"></i>
                    <h3 class="font-semibold">Animation Timeline</h3>
                </div>
                <div class="flex items-center space-x-2">
                    <button class="tool-btn px-2 py-1 rounded text-sm" id="play-btn">
                        <i class="fas fa-play"></i>
                    </button>
                    <button class="tool-btn px-2 py-1 rounded text-sm" id="pause-btn">
                        <i class="fas fa-pause"></i>
                    </button>
                    <button class="tool-btn px-2 py-1 rounded text-sm" id="stop-btn">
                        <i class="fas fa-stop"></i>
                    </button>
                    <button class="tool-btn px-2 py-1 rounded text-sm" id="record-btn">
                        <i class="fas fa-circle text-red-500"></i>
                    </button>
                    <span class="text-xs text-gray-400 mx-2" id="time-indicator">00:00 / 00:00</span>
                </div>
                <div class="flex items-center space-x-2">
                    <button class="tool-btn px-2 py-1 rounded text-sm" id="add-keyframe-btn">
                        <i class="fas fa-key"></i> Add Keyframe
                    </button>
                    <button class="tool-btn px-2 py-1 rounded text-sm text-red-400" id="delete-timeline-btn">
                        <i class="fas fa-trash"></i>
                    </button>
                </div>
            </div>

            <!-- Timeline Content -->
            <div class="flex-1 flex overflow-hidden">
                <!-- Track Names -->
                <div class="w-48 border-r border-gray-800/50 overflow-y-auto scrollbar" id="track-names">
                    <div class="py-1">
                        <div class="track-item px-3 py-1 flex items-center justify-between">
                            <span class="text-sm">Scene Properties</span>
                            <i class="fas fa-chevron-down text-xs text-gray-500"></i>
                        </div>
                        <div id="object-tracks">
                            <!-- Object tracks will be added here dynamically -->
                        </div>
                    </div>
                </div>

                <!-- Timeline Grid -->
                <div class="flex-1 overflow-auto relative" id="timeline-grid">
                    <!-- Frame Numbers -->
                    <div class="frame-numbers absolute top-0 h-6 flex" id="frame-numbers">
                        <!-- Frame numbers will be added here dynamically -->
                    </div>

                    <!-- Tracks -->
                    <div class="tracks-container absolute top-6 bottom-0 w-full">
                        <!-- Playhead -->
                        <div class="playhead absolute top-0 bottom-0 w-px bg-red-500 z-10" style="left: 40px;"
                            id="playhead"></div>

                        <!-- Keyframes -->
                        <div id="tracks-content" class="absolute top-0 bottom-0 w-full">
                            <!-- Keyframes will be added here dynamically -->
                        </div>
                    </div>
                </div>
            </div>

            <!-- Timeline Footer -->
            <div class="border-t border-gray-800/50 px-4 py-2 flex items-center justify-between">
                <div class="flex items-center space-x-4">
                    <div class="flex items-center">
                        <span class="text-xs text-gray-400 mr-2">FPS:</span>
                        <input id="fps-input" type="number" min="1" max="120" value="24"
                            class="property-input w-12 px-2 py-1 rounded text-sm">
                    </div>
                    <div class="flex items-center">
                        <span class="text-xs text-gray-400 mr-2">Start:</span>
                        <input id="start-frame-input" type="number" min="0" value="0"
                            class="property-input w-12 px-2 py-1 rounded text-sm">
                    </div>
                    <div class="flex items-center">
                        <span class="text-xs text-gray-400 mr-2">End:</span>
                        <input id="end-frame-input" type="number" min="1" value="100"
                            class="property-input w-12 px-2 py-1 rounded text-sm">
                    </div>
                </div>
                <div class="flex items-center space-x-2">
                    <button class="tool-btn px-2 py-1 rounded text-sm" id="zoom-in-btn">
                        <i class="fas fa-search-plus"></i>
                    </button>
                    <button class="tool-btn px-2 py-1 rounded text-sm" id="zoom-out-btn">
                        <i class="fas fa-search-minus"></i>
                    </button>
                    <button class="tool-btn px-2 py-1 rounded text-sm" id="fit-to-view-btn">
                        <i class="fas fa-expand"></i>
                    </button>
                </div>
            </div>
        </div>
        <!-- Status Bar -->
        <footer class="status-bar h-8 px-6 flex items-center justify-between text-xs text-gray-400 code-font">
            <div class="flex items-center space-x-6">
                <span id="object-count">Objects: 0</span>
                <span id="triangle-count">Triangles: 0</span>
                <span id="vertex-count">Vertices: 0</span>
            </div>
            <div class="flex items-center space-x-6">
                <span id="zoom-level">Zoom: 100%</span>
                <span id="fps-counter">FPS: 60</span>
                <span class="flex items-center">
                    <div class="w-1.5 h-1.5 bg-primary-400 rounded-full mr-2"></div>
                    <span id="status-message">Ready</span>
                </span>
            </div>
        </footer>
    </div>

    <!-- Context Menu -->
    <div id="context-menu" class="context-menu fixed hidden min-w-[200px] py-2 z-50">
        <div class="context-item px-4 py-2 text-sm cursor-pointer" id="context-add-object">
            <i class="fas fa-plus w-4 mr-3"></i>Add Object
        </div>
        <div class="context-item px-4 py-2 text-sm cursor-pointer" id="context-paste">
            <i class="fas fa-paste w-4 mr-3"></i>Paste
        </div>
        <div class="h-px bg-gray-700 mx-2"></div>
        <div class="context-item px-4 py-2 text-sm cursor-pointer" id="context-select-all">
            <i class="fas fa-eye w-4 mr-3"></i>Select All
        </div>
        <!-- Add new context menu items -->
        <div class="context-item px-4 py-2 text-sm cursor-pointer" id="context-group">
            <i class="fas fa-object-group w-4 mr-3"></i>Group
        </div>
        <div class="context-item px-4 py-2 text-sm cursor-pointer" id="context-ungroup">
            <i class="fas fa-object-ungroup w-4 mr-3"></i>Ungroup
        </div>
        <div class="h-px bg-gray-700 mx-2"></div>
        <div class="context-item px-4 py-2 text-sm cursor-pointer" id="context-hide">
            <i class="fas fa-eye-slash w-4 mr-3"></i>Hide
        </div>
        <div class="context-item px-4 py-2 text-sm cursor-pointer" id="context-freeze">
            <i class="fas fa-snowflake w-4 mr-3"></i>Freeze
        </div>
    </div>

    <!-- Notification -->
    <div class="notification" id="notification">
        <div class="flex items-center">
            <i class="fas fa-check-circle text-green-400 mr-2"></i>
            <span id="notification-message">Operation completed</span>
        </div>
    </div>

    <!-- File Input (hidden) -->
    <input type="file" id="file-input" accept=".json,.gltf,.glb" style="display: none;">
    <input type="file" id="image-input" accept="image/*" style="display: none;">

    <script>
        // ==============================================
        // CORE APPLICATION CLASSES
        // ==============================================

        class AppState {
            constructor() {
                this.animation = {
                    currentFrame: 0,
                    fps: 24,
                    startFrame: 0,
                    endFrame: 100,
                    isPlaying: false,
                    isRecording: false,
                    tracks: {},
                    selectedKeyframes: [],
                    playheadPosition: 0,
                    zoomLevel: 1,
                    snapToFrames: true,
                    loop: true
                };
                this.animationClock = new THREE.Clock();

                this.clipboard = {
                    keyframes: null,
                    type: null
                };
                this.resetState();
                this.layers = {
                    default: { id: 0, name: 'Default', visible: true, objects: [] }
                };
                this.viewportSettings = {
                    shading: 'solid',
                    gridVisible: true,
                    axesVisible: false,
                    statsVisible: true
                };
                this.materialLibrary = [
                    {
                        name: 'Default',
                        color: 0x808080,
                        roughness: 0.5,
                        metalness: 0
                    },
                    {
                        name: 'Metal',
                        color: 0xaaaaaa,
                        roughness: 0.2,
                        metalness: 1.0
                    },
                    {
                        name: 'Plastic',
                        color: 0xffffff,
                        roughness: 0.4,
                        metalness: 0
                    }
                ];
                // Add this:
                this.sculpting = {
                    currentMesh: null,
                    originalPositions: null,
                    vertexNormals: null,
                    activeVertices: [],
                    lastCenter: null,
                    vertexGroups: new Map()
                };
                this.snapSettings = {
                    enabled: false,
                    value: 0.25,
                    axisConstraints: { x: true, y: true, z: true }
                };
                this.groups = [];
                this.hiddenObjects = [];
                this.frozenObjects = [];
                this.textures = {
                    diffuse: {},
                    normal: {},
                    roughness: {}
                };

            }

            resetState() {
                this.sceneObjects = [];
                this.selectedObjects = [];
                this.lastObjectId = 0;
                this.activeTool = 'select';
                this.viewMode = 'solid';
                this.cameraMode = 'perspective';
                this.transformMode = 'location';
                this.clipboard = null;
                this.history = [];
                this.historyIndex = -1;
                this.maxHistoryStates = 100;
                this.isDragging = false;
                this.dragStart = { x: 0, y: 0 };
                this.selectionBox = { start: { x: 0, y: 0 }, end: { x: 0, y: 0 } };
                this.performance = {
                    fps: 60,
                    frameTime: 16,
                    lastFrameTime: performance.now(),
                    frameCount: 0
                };
                this.brushSettings = {
                    size: 0.5,
                    strength: 0.5,
                    falloff: 0.5,
                    symmetry: 'none'
                };
            }
            // Add these new methods to AppState class
            // In AppState class
            addKeyframe(objectId, property, frame, value) {
                if (!this.animation.tracks[objectId]) {
                    this.animation.tracks[objectId] = {};
                }

                if (!this.animation.tracks[objectId][property]) {
                    this.animation.tracks[objectId][property] = [];
                }

                // Remove existing keyframe at this frame if it exists
                this.animation.tracks[objectId][property] = this.animation.tracks[objectId][property].filter(
                    kf => kf.frame !== frame
                );

                // Add new keyframe
                this.animation.tracks[objectId][property].push({
                    frame,
                    value: Array.isArray(value) ? [...value] : value,
                    interpolation: 'linear',
                    easing: 'linear'
                });

                // Sort keyframes by frame
                this.animation.tracks[objectId][property].sort((a, b) => a.frame - b.frame);

                this.saveHistory();
                window.uiManager.updateTimeline();
            }
            removeKeyframe(objectId, property, frame) {
                if (!this.animation.tracks[objectId] || !this.animation.tracks[objectId][property]) {
                    return false;
                }

                const initialLength = this.animation.tracks[objectId][property].length;
                this.animation.tracks[objectId][property] = this.animation.tracks[objectId][property].filter(
                    kf => kf.frame !== frame
                );

                if (this.animation.tracks[objectId][property].length !== initialLength) {
                    this.saveHistory();
                    return true;
                }
                return false;
            }

            getKeyframeValue(objectId, property, frame) {
                if (!this.animation.tracks[objectId] || !this.animation.tracks[objectId][property]) {
                    return null;
                }

                const keyframes = this.animation.tracks[objectId][property];
                if (keyframes.length === 0) return null;

                // Exact match
                const exact = keyframes.find(kf => kf.frame === frame);
                if (exact) return exact.value;

                // Before first keyframe
                if (frame < keyframes[0].frame) return keyframes[0].value;

                // After last keyframe
                if (frame > keyframes[keyframes.length - 1].frame) return keyframes[keyframes.length - 1].value;

                // Find surrounding keyframes
                let prev = keyframes[0];
                let next = keyframes[keyframes.length - 1];

                for (let i = 0; i < keyframes.length - 1; i++) {
                    if (keyframes[i].frame <= frame && keyframes[i + 1].frame >= frame) {
                        prev = keyframes[i];
                        next = keyframes[i + 1];
                        break;
                    }
                }

                // Calculate interpolation
                const t = (frame - prev.frame) / (next.frame - prev.frame);
                return this.interpolate(prev, next, t);
            }

            interpolate(prev, next, t) {
                if (prev.interpolation === 'constant') {
                    return prev.value;
                }

                if (prev.interpolation === 'linear') {
                    if (Array.isArray(prev.value)) {
                        return prev.value.map((v, i) => v + (next.value[i] - v) * t);
                    }
                    return prev.value + (next.value - prev.value) * t;
                }

                if (prev.interpolation === 'bezier') {
                    // Cubic bezier interpolation using handles
                    // This is simplified - a full implementation would need more math
                    if (Array.isArray(prev.value)) {
                        return prev.value.map((v, i) => v + (next.value[i] - v) * t);
                    }
                    return prev.value + (next.value - prev.value) * t;
                }

                // Default to linear
                if (Array.isArray(prev.value)) {
                    return prev.value.map((v, i) => v + (next.value[i] - v) * t);
                }
                return prev.value + (next.value - prev.value) * t;
            }

            updateAnimation(deltaTime) {
                if (!this.animation.isPlaying) return;

                const delta = this.animationClock.getDelta();
                this.animation.currentFrame += delta * this.animation.fps;

                // Handle looping or stopping at end frame
                if (this.animation.currentFrame > this.animation.endFrame) {
                    if (this.animation.loop) {
                        this.animation.currentFrame = this.animation.startFrame;
                    } else {
                        this.animation.currentFrame = this.animation.endFrame;
                        this.animation.isPlaying = false;
                        return;
                    }
                }

                // Apply the animation for the current frame
                this.applyAnimation(this.animation.currentFrame);
            }
            getInterpolatedValue(objectId, property, frame) {
                const keyframes = this.appState.animation.tracks[objectId][property];
                if (!keyframes || keyframes.length === 0) return null;

                // Find surrounding keyframes
                let prev = keyframes[0];
                let next = keyframes[keyframes.length - 1];

                for (let i = 0; i < keyframes.length - 1; i++) {
                    if (keyframes[i].frame <= frame && keyframes[i + 1].frame >= frame) {
                        prev = keyframes[i];
                        next = keyframes[i + 1];
                        break;
                    }
                }

                // Calculate interpolation
                const t = (frame - prev.frame) / (next.frame - prev.frame);
                return this.interpolate(prev.value, next.value, t, prev.interpolation);
            }
            interpolate(a, b, t, method = 'linear') {
                if (method === 'constant') return a;
                if (method === 'linear') {
                    if (Array.isArray(a)) {
                        return a.map((v, i) => v + (b[i] - v) * t);
                    }
                    return a + (b - a) * t;
                }
                // Add other interpolation methods as needed
                return a;
            }
            applyPropertyValue(obj, property, value) {
                switch (property) {
                    case 'position':
                        obj.position.set(value[0], value[1], value[2]);
                        break;
                    case 'rotation':
                        obj.rotation.set(value[0], value[1], value[2]);
                        break;
                    case 'scale':
                        obj.scale.set(value[0], value[1], value[2]);
                        break;
                    case 'visible':
                        obj.visible = value;
                        break;
                    case 'material.color':
                        if (obj.material) {
                            obj.material.color.setHex(value);
                        }
                        break;
                    // Add more properties as needed
                }
            }
            applyAnimation(frame) {
                frame = Math.round(frame);
                this.animation.currentFrame = frame;

                Object.keys(this.animation.tracks).forEach(objectId => {
                    const obj = this.sceneManager.getObject(objectId);
                    if (!obj) return;

                    const tracks = this.animation.tracks[objectId];
                    Object.keys(tracks).forEach(property => {
                        const value = this.getInterpolatedValue(objectId, property, frame);
                        if (value === null) return;

                        this.applyPropertyValue(obj, property, value);
                    });
                });

                if (window.uiManager) {
                    window.uiManager.updateTimeline();
                }
            }
            copyKeyframes() {
                const selected = this.animation.selectedKeyframes;
                if (selected.length === 0) return false;

                this.clipboard = {
                    keyframes: JSON.parse(JSON.stringify(selected)),
                    type: 'keyframes'
                };

                return true;
            }

            pasteKeyframes(targetFrame) {
                if (!this.clipboard.keyframes || this.clipboard.type !== 'keyframes') {
                    return false;
                }

                const frameOffset = targetFrame - this.clipboard.keyframes[0].frame;

                this.clipboard.keyframes.forEach(kf => {
                    this.addKeyframe(
                        kf.objectId,
                        kf.property,
                        kf.frame + frameOffset,
                        kf.value
                    );
                });

                return true;
            }

            // Add this to existing methods
            serializeState() {
                return {
                    // ... existing properties
                    animation: {
                        currentFrame: this.animation.currentFrame,
                        fps: this.animation.fps,
                        startFrame: this.animation.startFrame,
                        endFrame: this.animation.endFrame,
                        tracks: JSON.parse(JSON.stringify(this.animation.tracks)),
                        zoomLevel: this.animation.zoomLevel,
                        snapToFrames: this.animation.snapToFrames
                    }
                };
            }

            generateId() {
                return ++this.lastObjectId;
            }

            addObject(object) {
                if (!object.id) object.id = this.generateId();
                this.sceneObjects.push(object);
                this.saveHistory();
                return object;
            }

            removeObject(objectId) {
                const index = this.sceneObjects.findIndex(obj => obj.id === objectId);
                if (index > -1) {
                    this.sceneObjects.splice(index, 1);
                    this.deselectObject(objectId);
                    this.saveHistory();
                    return true;
                }
                return false;
            }

            getObject(objectId) {
                return this.sceneObjects.find(obj => obj.id === objectId);
            }

            selectObject(objectId, multiSelect = false) {
                if (!multiSelect) {
                    this.selectedObjects = [];
                }

                if (!this.selectedObjects.includes(objectId)) {
                    this.selectedObjects.push(objectId);
                }
            }

            deselectObject(objectId) {
                this.selectedObjects = this.selectedObjects.filter(id => id !== objectId);
            }

            clearSelection() {
                this.selectedObjects = [];
            }

            getSelectedObjects() {
                return this.sceneObjects.filter(obj => this.selectedObjects.includes(obj.id));
            }

            // Save current state to history
            saveHistory() {
                // Skip saving if we're in the middle of a sculpt operation
                if (this.activeTool === 'sculpt' && this.isDragging) {
                    return;
                }

                const currentState = this.serializeState();
                const serializedState = JSON.stringify(currentState);

                // Don't save if identical to last state
                if (this.history[this.historyIndex] === serializedState) {
                    return;
                }

                // If we're not at the end of history, discard future states
                if (this.historyIndex < this.history.length - 1) {
                    this.history = this.history.slice(0, this.historyIndex + 1);
                }

                // Limit history size
                if (this.history.length >= this.maxHistoryStates) {
                    this.history.shift();
                } else {
                    this.historyIndex++;
                }

                this.history.push(serializedState);
            }

            undo() {
                if (this.historyIndex <= 0) return false;

                this.historyIndex--;
                this.restoreState(JSON.parse(this.history[this.historyIndex]));
                return true;
            }

            // Redo to next state
            redo() {
                if (this.historyIndex >= this.history.length - 1) return false;

                this.historyIndex++;
                this.restoreState(JSON.parse(this.history[this.historyIndex]));
                return true;
            }
            // Restore a state from serialized data
            restoreState(state) {
                if (state.animation) {
                    this.animation.currentFrame = state.animation.currentFrame || 0;
                    this.animation.fps = state.animation.fps || 24;
                    this.animation.startFrame = state.animation.startFrame || 0;
                    this.animation.endFrame = state.animation.endFrame || 100;
                    this.animation.tracks = state.animation.tracks || {};
                    this.animation.zoomLevel = state.animation.zoomLevel || 1;
                    this.animation.snapToFrames = state.animation.snapToFrames !== undefined ?
                        state.animation.snapToFrames : true;
                }
                // Clear current scene
                this.sceneObjects = [];
                this.sceneManager.scene.children.forEach(child => {
                    if (child !== this.sceneManager.camera &&
                        child !== this.sceneManager.controls &&
                        child !== this.sceneManager.gridHelper &&
                        child !== this.sceneManager.axesHelper) {
                        this.sceneManager.scene.remove(child);
                    }
                });

                // Restore objects
                state.sceneObjects.forEach(objData => {
                    const obj = {
                        id: objData.id,
                        type: objData.type,
                        name: objData.name,
                        userData: objData.userData
                    };

                    this.sceneObjects.push(obj);
                    const threeObj = this.sceneManager.addObject(obj);

                    if (threeObj && threeObj.threeObj) {
                        threeObj.threeObj.position.copy(objData.position);
                        threeObj.threeObj.rotation.copy(objData.rotation);
                        threeObj.threeObj.scale.copy(objData.scale);
                        threeObj.threeObj.visible = objData.visible;

                        if (threeObj.threeObj.material) {
                            threeObj.threeObj.material.color.setHex(objData.color);
                            threeObj.threeObj.material.roughness = objData.roughness;
                            threeObj.threeObj.material.metalness = objData.metalness;
                            threeObj.threeObj.material.needsUpdate = true;
                        }
                    }
                });

                // Restore selection
                this.selectedObjects = [...state.selectedObjects];

                // Restore camera
                if (state.camera && this.sceneManager.camera) {
                    this.sceneManager.camera.position.copy(state.camera.position);
                    this.sceneManager.camera.rotation.copy(state.camera.rotation);
                    if (this.sceneManager.camera.zoom !== undefined) {
                        this.sceneManager.camera.zoom = state.camera.zoom;
                        this.sceneManager.camera.updateProjectionMatrix();
                    }
                }

                // Restore view mode and active tool
                this.viewMode = state.viewMode || 'solid';
                this.activeTool = state.activeTool || 'select';

                // Update UI
                if (window.uiManager) {
                    window.uiManager.updateUI();
                    window.uiManager.updateViewModeButtons();
                    window.uiManager.updateToolButtons();
                }

                // Update scene manager
                this.sceneManager.setViewMode(this.viewMode);

                // Update selection in scene manager
                if (this.selectedObjects.length > 0) {
                    this.sceneManager.selectObject(this.selectedObjects[0]);
                } else {
                    this.sceneManager.clearSelection();
                }
            }

            toggleSnap(enabled) {
                this.snapSettings.enabled = enabled;
            }
            // In AppState class
            getSelectedThreeObjects(sceneManager) {
                return this.selectedObjects.map(id => sceneManager.getObject(id)).filter(obj => obj !== null);
            }
            setSnapValue(value) {
                this.snapSettings.value = parseFloat(value) || 0.25;
            }
            // Serialize the current state
            serializeState() {
                return {
                    sceneObjects: this.sceneObjects.map(obj => this.serializeObject(obj)),
                    selectedObjects: [...this.selectedObjects],
                    camera: {
                        position: this.sceneManager?.camera?.position?.clone() || new THREE.Vector3(5, 5, 5),
                        rotation: this.sceneManager?.camera?.rotation?.clone() || new THREE.Euler(),
                        zoom: this.sceneManager?.camera?.zoom || 1
                    },
                    viewMode: this.viewMode,
                    activeTool: this.activeTool
                };
            }

            // Serialize a single object
            serializeObject(obj) {
                const threeObj = this.sceneManager?.getObject(obj.id);
                return {
                    id: obj.id,
                    type: obj.type,
                    name: obj.name || `${obj.type}_${obj.id}`,
                    position: threeObj?.position?.clone() || new THREE.Vector3(0, 0, 0),
                    rotation: threeObj?.rotation?.clone() || new THREE.Euler(0, 0, 0),
                    scale: threeObj?.scale?.clone() || new THREE.Vector3(1, 1, 1),
                    color: threeObj?.material?.color?.getHex() || 0x808080,
                    roughness: threeObj?.material?.roughness || 0.5,
                    metalness: threeObj?.material?.metalness || 0,
                    visible: threeObj?.visible ?? true,
                    userData: { ...obj.userData }
                };
            }


            getMeshState(mesh) {
                if (!mesh || !mesh.geometry) return null;

                return {
                    positions: mesh.geometry.attributes.position.array.slice(),
                    normals: mesh.geometry.attributes.normal?.array.slice(),
                    indices: mesh.geometry.index?.array.slice()
                };
            }

            toggleAxisConstraint(axis) {
                if (this.snapSettings.axisConstraints.hasOwnProperty(axis)) {
                    this.snapSettings.axisConstraints[axis] = !this.snapSettings.axisConstraints[axis];
                }
            }
            copySelectedObjects() {
                const selectedObjects = this.getSelectedObjects();
                if (selectedObjects.length === 0) return null;

                // Create deep copies of the selected objects
                const copies = selectedObjects.map(obj => {
                    return {
                        ...obj,
                        id: this.generateId(),
                        name: `${obj.name}_copy` || `${obj.type}_${this.lastObjectId}`,
                        position: obj.position ? { ...obj.position } : null,
                        rotation: obj.rotation ? { ...obj.rotation } : null,
                        scale: obj.scale ? { ...obj.scale } : null
                    };
                });

                return copies;
            }
            groupObjects(objectIds) {
                if (objectIds.length < 2) return;
                const groupId = this.generateId();
                this.groups.push({
                    id: groupId,
                    name: `Group_${groupId}`,
                    objects: objectIds
                });
                this.saveHistory();
            }

            ungroupObjects(groupId) {
                const index = this.groups.findIndex(g => g.id === groupId);
                if (index > -1) {
                    this.groups.splice(index, 1);
                    this.saveHistory();
                }
            }
            addKeyframe(objectId, property, frame, value) {
                if (!this.animation.tracks[objectId]) {
                    this.animation.tracks[objectId] = {};
                }

                if (!this.animation.tracks[objectId][property]) {
                    this.animation.tracks[objectId][property] = [];
                }

                // Remove existing keyframe at this frame
                this.animation.tracks[objectId][property] =
                    this.animation.tracks[objectId][property].filter(kf => kf.frame !== frame);

                // Add new keyframe
                this.animation.tracks[objectId][property].push({
                    frame,
                    value: Array.isArray(value) ? [...value] : value,
                    interpolation: 'linear',
                    inTangent: 0,
                    outTangent: 0
                });

                // Sort by frame
                this.animation.tracks[objectId][property].sort((a, b) => a.frame - b.frame);

                this.saveHistory();
            }
            interpolateKeyframes(prev, next, t, property) {
                if (property === 'rotation') {
                    // Use quaternion slerp for rotations
                    const q1 = new THREE.Quaternion().setFromEuler(
                        new THREE.Euler(prev.value[0], prev.value[1], prev.value[2])
                    );
                    const q2 = new THREE.Quaternion().setFromEuler(
                        new THREE.Euler(next.value[0], next.value[1], next.value[2])
                    );
                    const result = new THREE.Quaternion();
                    result.slerpQuaternions(q1, q2, t);
                    const euler = new THREE.Euler().setFromQuaternion(result);
                    return [euler.x, euler.y, euler.z];
                } else {
                    // Linear interpolation for other properties
                    if (Array.isArray(prev.value)) {
                        return prev.value.map((v, i) =>
                            v + (next.value[i] - v) * t
                        );
                    }
                    return prev.value + (next.value - prev.value) * t;
                }
            }
            toggleObjectVisibility(objectId) {
                const index = this.hiddenObjects.indexOf(objectId);
                if (index > -1) {
                    this.hiddenObjects.splice(index, 1);
                } else {
                    this.hiddenObjects.push(objectId);
                }
                this.saveHistory();
            }

            toggleObjectFreeze(objectId) {
                const index = this.frozenObjects.indexOf(objectId);
                if (index > -1) {
                    this.frozenObjects.splice(index, 1);
                } else {
                    this.frozenObjects.push(objectId);
                }
                this.saveHistory();
            }

            updatePerformance(deltaTime) {
                this.performance.frameCount++;
                if (performance.now() >= this.performance.lastFrameTime + 1000) {
                    this.performance.fps = Math.min(60, Math.round(this.performance.frameCount /
                        (performance.now() - this.performance.lastFrameTime) * 1000));
                    this.performance.frameCount = 0;
                    this.performance.lastFrameTime = performance.now();
                }
                this.performance.frameTime = deltaTime * 1000;
            }
        }

        class SceneManager {
            constructor(canvas) {
                if (!canvas) throw new Error('Canvas element is required');
                this.canvas = canvas;
                this.stats = {
                    triangles: 0,
                    vertices: 0,
                    drawCalls: 0
                };
                this.initThreeJS();
                this.setupLighting();
                this.setupHelpers();
                this.setupRaycasting();
                this.setupTransformControls();
                this.setupSculpting();
                this.setupBrushPreview(); // Add this line
                this.setupAnimationSystem();
            }

            initThreeJS() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x1a1a1a);

                this.renderer = new THREE.WebGLRenderer({
                    canvas: this.canvas,
                    antialias: true,
                    alpha: true,
                    powerPreference: "high-performance"
                });
                this.configureRenderer();

                this.camera = new THREE.PerspectiveCamera(
                    75,
                    this.canvas.clientWidth / this.canvas.clientHeight,
                    0.1,
                    1000
                );
                this.resetCamera();

                this.controls = new THREE.OrbitControls(this.camera, this.canvas);
                this.configureOrbitControls();
                const animate = () => {
                    requestAnimationFrame(animate);
                    this.renderer.render(this.scene, this.camera);
                };
                animate();
            }

            setupRaycasting() {
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
            }

            setupTransformControls() {
                this.transformControls = new THREE.TransformControls(this.camera, this.renderer.domElement);

                // Improved event handling
                this.transformControls.addEventListener('dragging-changed', (event) => {
                    this.controls.enabled = !event.value;
                    if (!event.value) {
                        // When dragging ends, ensure the active tool is still selected
                        window.uiManager?.updateToolButtons();
                    }
                });

                this.transformControls.addEventListener('mouseDown', () => {
                    const uiManager = window.uiManager;
                    if (uiManager) {
                        uiManager.appState.activeTool = this.transformControls.getMode();
                        uiManager.updateToolButtons();
                    }
                });

                this.scene.add(this.transformControls);
                this.transformControls.visible = false;
                this.transformControls.enabled = false; // Start disabled
            }

            resetCamera(position = { x: 5, y: 5, z: 5 }) {
                this.camera.position.set(position.x, position.y, position.z);
                this.camera.lookAt(0, 0, 0);
                this.camera.up.set(0, 1, 0);
            }

            configureRenderer() {
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.setSize(this.canvas.clientWidth, this.canvas.clientHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                this.renderer.outputEncoding = THREE.sRGBEncoding;
                this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                this.renderer.toneMappingExposure = 1.0;
            }

            configureOrbitControls() {
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.25;
                this.controls.screenSpacePanning = false;
                this.controls.maxPolarAngle = Math.PI;
                this.controls.minDistance = 1;
                this.controls.maxDistance = 50;
            }

            setupLighting() {
                this.ambientLight = new THREE.AmbientLight(0x404040, 1);
                this.scene.add(this.ambientLight);

                this.directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                this.directionalLight.position.set(5, 10, 7);
                this.directionalLight.castShadow = true;
                this.directionalLight.shadow.mapSize.width = 2048;
                this.directionalLight.shadow.mapSize.height = 2048;
                this.directionalLight.shadow.camera.near = 0.5;
                this.directionalLight.shadow.camera.far = 50;
                this.directionalLight.shadow.bias = -0.001;
                this.scene.add(this.directionalLight);

                this.hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.5);
                this.scene.add(this.hemisphereLight);
            }
            duplicateObject(objectData) {
                // Create a new object with the same properties but new ID
                const newObject = this.addObject(objectData);
                if (newObject) {
                    // Offset the position slightly so duplicates don't overlap
                    newObject.threeObj.position.x += 0.5;
                    newObject.threeObj.position.z += 0.5;
                }
                return newObject;
            }
            getMeshUnderPointer(mouse) {
                this.raycaster.setFromCamera(mouse, this.camera);
                const intersects = this.raycaster.intersectObjects(this.scene.children, true);

                for (let i = 0; i < intersects.length; i++) {
                    if (intersects[i].object.isMesh) {
                        return intersects[i];
                    }
                }
                return null;
            }

            getMeshVerticesInRadius(mesh, point, radius) {
                const vertices = [];
                const geometry = mesh.geometry;
                const positionAttribute = geometry.getAttribute('position');
                const matrixWorld = mesh.matrixWorld;
                const inverseMatrix = new THREE.Matrix4().getInverse(matrixWorld);

                // Transform point to mesh local space
                const localPoint = point.clone().applyMatrix4(inverseMatrix);

                for (let i = 0; i < positionAttribute.count; i++) {
                    const vertex = new THREE.Vector3().fromBufferAttribute(positionAttribute, i);
                    const distance = vertex.distanceTo(localPoint);

                    if (distance <= radius) {
                        vertices.push({
                            index: i,
                            distance: distance,
                            originalPosition: vertex.clone(),
                            normal: this.getVertexNormal(mesh, i)
                        });
                    }
                }

                return vertices;
            }
            // Add to SceneManager class
            setupBrushPreview() {
                this.brushPreview = new THREE.Mesh(
                    new THREE.SphereGeometry(1, 16, 16),
                    new THREE.MeshBasicMaterial({
                        color: 0x00ff00,
                        transparent: true,
                        opacity: 0.3,
                        wireframe: true
                    })
                );
                this.brushPreview.visible = false;
                this.scene.add(this.brushPreview);
            }
            updateBrushPreview(position, size) {
                this.brushPreview.position.copy(position);
                this.brushPreview.scale.set(size, size, size);
                this.brushPreview.visible = true;
            }

            hideBrushPreview() {
                this.brushPreview.visible = false;

            }
            prepareMeshForSculpting(mesh) {
                if (!mesh.geometry) return false;

                // Convert to non-indexed geometry if needed
                if (mesh.geometry.index) {
                    mesh.geometry = mesh.geometry.toNonIndexed();
                }

                // Ensure we can modify the geometry
                mesh.geometry.attributes.position.needsUpdate = true;
                if (mesh.geometry.attributes.normal) {
                    mesh.geometry.attributes.normal.needsUpdate = true;
                }

                // Store original positions
                const positions = mesh.geometry.attributes.position.array;
                this.sculpting.originalPositions = new Float32Array(positions);

                // Compute normals if needed
                if (!mesh.geometry.attributes.normal) {
                    mesh.geometry.computeVertexNormals();
                }

                return true;
            }
            calculateVertexNormals(mesh) {
                const geometry = mesh.geometry;
                geometry.computeVertexNormals();
                this.sculpting.vertexNormals = [];

                const normals = geometry.getAttribute('normal');
                for (let i = 0; i < normals.count; i++) {
                    this.sculpting.vertexNormals.push(
                        new THREE.Vector3().fromBufferAttribute(normals, i)
                    );
                }
            }

            updateMeshVertices(mesh, vertices, newPositions) {
                const positionAttribute = mesh.geometry.getAttribute('position');

                for (let i = 0; i < vertices.length; i++) {
                    const vertex = vertices[i];
                    const newPosition = newPositions[i];
                    positionAttribute.setXYZ(vertex.index, newPosition.x, newPosition.y, newPosition.z);
                }

                positionAttribute.needsUpdate = true;
                mesh.geometry.computeVertexNormals();
            }
            setupHelpers() {
                this.gridHelper = new THREE.GridHelper(20, 20, 0x555555, 0x333333);
                this.gridHelper.position.y = -0.01;
                this.scene.add(this.gridHelper);

                this.axesHelper = new THREE.AxesHelper(5);
                this.axesHelper.visible = false;
                this.scene.add(this.axesHelper);

                this.selectionBox = new THREE.BoxHelper();
                this.selectionBox.material.depthTest = false;
                this.selectionBox.material.transparent = true;
                this.selectionBox.visible = false;
                this.scene.add(this.selectionBox);
            }
            // Add this method
            setupAnimationHelpers() {
                // Playhead visualization
                this.playhead = new THREE.Mesh(
                    new THREE.PlaneGeometry(0.5, 10),
                    new THREE.MeshBasicMaterial({ color: 0xff0000 })
                );
                this.playhead.rotation.x = -Math.PI / 2;
                this.playhead.position.y = 0.01;
                this.playhead.visible = false;
                this.scene.add(this.playhead);

                // Keyframe visualization
                this.keyframeVisualization = new THREE.Group();
                this.scene.add(this.keyframeVisualization);
            }
            prepareMeshForSculpting(mesh) {
                if (!mesh.geometry) return false;

                // Convert to non-indexed geometry if needed
                if (mesh.geometry.index) {
                    mesh.geometry = mesh.geometry.toNonIndexed();
                }

                // Ensure we can modify the geometry
                mesh.geometry.attributes.position.needsUpdate = true;
                if (mesh.geometry.attributes.normal) {
                    mesh.geometry.attributes.normal.needsUpdate = true;
                }

                // Store original positions
                const positions = mesh.geometry.attributes.position.array;
                this.sculpting.originalPositions = new Float32Array(positions);

                // Compute normals if needed
                if (!mesh.geometry.attributes.normal) {
                    mesh.geometry.computeVertexNormals();
                }

                return true;
            }
            // Add this method
            updateAnimationHelpers(frame) {
                if (!this.animation || !this.animation.tracks) return;
                if (!this.playhead) return;

                // Update playhead position
                const frameWidth = 0.5;
                const gridSize = 20;
                const framesPerUnit = gridSize / 100; // Assuming 100 frames fit in grid

                this.playhead.position.z = -gridSize / 2 + (frame * framesPerUnit);
                this.playhead.visible = true;

                // Update keyframe markers
                this.keyframeVisualization.children.forEach(child => {
                    this.keyframeVisualization.remove(child);
                });

                // Add markers for keyframes at current frame
                Object.keys(this.appState.animation.tracks).forEach(objectId => {
                    const obj = this.getObject(objectId);
                    if (!obj) return;

                    const tracks = this.appState.animation.tracks[objectId];
                    Object.keys(tracks).forEach(property => {
                        const keyframes = tracks[property];
                        keyframes.forEach(kf => {
                            if (kf.frame === frame) {
                                const marker = new THREE.Mesh(
                                    new THREE.SphereGeometry(0.2),
                                    new THREE.MeshBasicMaterial({
                                        color: this.getKeyframeColor(property)
                                    })
                                );
                                marker.position.copy(obj.position);
                                marker.position.y += 1; // Slightly above object
                                this.keyframeVisualization.add(marker);
                            }
                        });
                    });
                });
            }

            // Helper method
            getKeyframeColor(property) {
                switch (property) {
                    case 'position': return 0x4d9eff; // Blue
                    case 'rotation': return 0xff9e4d; // Orange
                    case 'scale': return 0x4dff9e; // Green
                    case 'visible': return 0xff4d9e; // Pink
                    default: return 0xffffff; // White
                }
            }
            calculateBrushInfluence(distance, size, falloff) {
                if (distance >= size) return 0;

                const t = distance / size;

                // Different falloff curves based on falloff value
                if (falloff < 0.33) return 1 - t; // Linear
                if (falloff < 0.66) return 1 - t * t; // Quadratic
                return 1 - Math.pow(t, 4); // Sharp falloff
            }
            resize() {
                const width = this.canvas.clientWidth;
                const height = this.canvas.clientHeight;

                if (this.canvas.width !== width || this.canvas.height !== height) {
                    this.camera.aspect = width / height;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(width, height, false);
                }
            }
            calculateNewPosition(position, center, normal, strength, mode) {
                const newPos = position.clone();
                const direction = new THREE.Vector3().subVectors(center, position).normalize();

                switch (mode) {
                    case 'draw':
                        newPos.add(normal.multiplyScalar(strength));
                        break;
                    case 'smooth':
                        newPos.lerp(center, strength * 0.1);
                        break;
                    case 'flatten':
                        const plane = new THREE.Plane().setFromNormalAndCoplanarPoint(normal, center);
                        const projected = plane.projectPoint(position, new THREE.Vector3());
                        newPos.lerp(projected, strength);
                        break;
                    case 'inflate':
                        newPos.add(direction.multiplyScalar(-strength));
                        break;
                    case 'pinch':
                        newPos.add(direction.multiplyScalar(strength));
                        break;
                    case 'grab':
                        if (this.sculpting.lastCenter) {
                            const moveVec = new THREE.Vector3().subVectors(center, this.sculpting.lastCenter);
                            newPos.add(moveVec.multiplyScalar(strength));
                        }
                        break;
                    case 'crevice':
                        newPos.add(normal.multiplyScalar(-strength));
                        break;
                }

                return newPos;
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                const now = performance.now();
                const deltaTime = (now - this.lastFrameTime) / 1000;
                this.lastFrameTime = now;
                // Update animations
                const delta = this.animationClock.getDelta();
                if (this.mixer) {
                    this.mixer.update(delta);
                }

                // Update animation
                this.appState.updateAnimation(deltaTime);
                this.updateAnimationHelpers(this.appState.animation.currentFrame);
                this.controls.update();
                this.renderer.render(this.scene, this.camera);
            }

            addObject(objectData) {
                let object3D;
                let helper = null;

                switch (objectData.type) {
                    case 'box':
                        object3D = this.createBox(objectData);
                        break;
                    case 'sphere':
                        object3D = this.createSphere(objectData);
                        break;
                    case 'cylinder':
                        object3D = this.createCylinder(objectData);
                        break;
                    case 'cone':
                        object3D = this.createCone(objectData);
                        break;
                    case 'torus':
                        object3D = this.createTorus(objectData);
                        break;
                    case 'plane':
                        object3D = this.createPlane(objectData);
                        break;
                    case 'extrude':
                        object3D = this.createExtrudedShape(objectData);
                        break;
                    case 'light':
                        object3D = this.createLight(objectData);
                        helper = new THREE.PointLightHelper(object3D, 0.5);
                        this.scene.add(helper);
                        break;
                    case 'camera':
                        object3D = this.createCamera(objectData);
                        helper = new THREE.CameraHelper(object3D);
                        this.scene.add(helper);
                        break;
                    default:
                        console.warn(`Unknown object type: ${objectData.type}`);
                        return null;
                }

                if (objectData.position) {
                    object3D.position.set(
                        objectData.position.x || 0,
                        objectData.position.y || 0,
                        objectData.position.z || 0
                    );
                }

                if (objectData.rotation) {
                    object3D.rotation.set(
                        objectData.rotation.x || 0,
                        objectData.rotation.y || 0,
                        objectData.rotation.z || 0
                    );
                }

                if (objectData.scale) {
                    object3D.scale.set(
                        objectData.scale.x || 1,
                        objectData.scale.y || 1,
                        objectData.scale.z || 1
                    );
                }

                object3D.userData = {
                    id: objectData.id,
                    type: objectData.type,
                    name: objectData.name || `${objectData.type}_${objectData.id}`,
                    helper: helper
                };

                this.scene.add(object3D);
                this.updateStats();

                return { threeObj: object3D, helper };
            }

            createBox(data) {
                const geometry = new THREE.BoxGeometry(1, 1, 1);
                const material = new THREE.MeshStandardMaterial({
                    color: new THREE.Color(data.color || 0x808080),
                    roughness: data.roughness || 0.5,
                    metalness: data.metalness || 0
                });

                const mesh = new THREE.Mesh(geometry, material);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                return mesh;
            }

            applyBrushEffect(mesh, vertices, center, normal, strength, mode) {
                const positions = mesh.geometry.attributes.position.array;
                const normals = mesh.geometry.attributes.normal.array;
                const size = this.appState.brushSettings.size || 1.0;
                const falloff = this.appState.brushSettings.falloff || 0.5;

                // Backup original positions (for flatten/mask)
                if (!mesh.userData.originalPositions) {
                    mesh.userData.originalPositions = new Float32Array(positions);
                }

                // Initialize mask attribute if needed
                if (mode === 'mask' && !mesh.geometry.attributes.mask) {
                    const maskArray = new Float32Array(positions.length / 3).fill(0);
                    mesh.geometry.setAttribute('mask', new THREE.BufferAttribute(maskArray, 1));
                }

                for (let i = 0; i < vertices.length; i++) {
                    const vIdx = vertices[i].index * 3;
                    const vx = positions[vIdx];
                    const vy = positions[vIdx + 1];
                    const vz = positions[vIdx + 2];
                    const nx = normals[vIdx];
                    const ny = normals[vIdx + 1];
                    const nz = normals[vIdx + 2];

                    // Calculate distance and influence
                    const dx = vx - center.x;
                    const dy = vy - center.y;
                    const dz = vz - center.z;
                    const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                    const influence = this.calculateBrushInfluence(distance, size, falloff);

                    if (influence <= 0) continue;

                    const effect = strength * influence;

                    // Apply brush effect
                    switch (mode) {
                        case 'draw': // Extrude along normal
                            positions[vIdx] += nx * effect;
                            positions[vIdx + 1] += ny * effect;
                            positions[vIdx + 2] += nz * effect;
                            break;

                        case 'smooth': // Average toward center
                            positions[vIdx] += (center.x - vx) * effect * 0.1;
                            positions[vIdx + 1] += (center.y - vy) * effect * 0.1;
                            positions[vIdx + 2] += (center.z - vz) * effect * 0.1;
                            break;

                        case 'flatten': // Project to plane
                            const planeDist = normal.x * (vx - center.x) + normal.y * (vy - center.y) + normal.z * (vz - center.z);
                            positions[vIdx] -= normal.x * planeDist * effect;
                            positions[vIdx + 1] -= normal.y * planeDist * effect;
                            positions[vIdx + 2] -= normal.z * planeDist * effect;
                            break;

                        case 'inflate': // Stronger extrude
                            positions[vIdx] += nx * effect * 1.5;
                            positions[vIdx + 1] += ny * effect * 1.5;
                            positions[vIdx + 2] += nz * effect * 1.5;
                            break;

                        case 'grab': // Pull toward center
                            positions[vIdx] += dx * effect * 0.2;
                            positions[vIdx + 1] += dy * effect * 0.2;
                            positions[vIdx + 2] += dz * effect * 0.2;
                            break;

                        case 'pinch': // Pinch toward center
                            positions[vIdx] -= dx * effect * 0.3;
                            positions[vIdx + 1] -= dy * effect * 0.3;
                            positions[vIdx + 2] -= dz * effect * 0.3;
                            break;

                        case 'crevice': // Push away + extrude
                            const creviceDirX = dx / distance;
                            const creviceDirY = dy / distance;
                            const creviceDirZ = dz / distance;
                            positions[vIdx] += (nx * 0.7 - creviceDirX * 0.3) * effect;
                            positions[vIdx + 1] += (ny * 0.7 - creviceDirY * 0.3) * effect;
                            positions[vIdx + 2] += (nz * 0.7 - creviceDirZ * 0.3) * effect;
                            break;

                        case 'mask': // Set mask value
                            mesh.geometry.attributes.mask.array[vertices[i].index] = influence;
                            break;

                        default:
                            console.error(`Unknown brush mode: ${mode}`);
                    }
                }

                // Update geometry
                mesh.geometry.attributes.position.needsUpdate = true;
                if (mode !== 'mask') mesh.geometry.computeVertexNormals();
                if (mode === 'mask') mesh.geometry.attributes.mask.needsUpdate = true;
            }
            createExtrudedShape(data) {
                // Create a simple star shape for extrusion
                const starShape = new THREE.Shape();
                const x = 0, y = 0;
                const spikes = 5;
                const outerRadius = 0.5;
                const innerRadius = 0.2;

                starShape.moveTo(x, y + outerRadius);
                for (let i = 0; i < spikes * 2; i++) {
                    const angle = (i * Math.PI) / spikes;
                    const radius = i % 2 === 0 ? outerRadius : innerRadius;
                    starShape.lineTo(
                        x + Math.sin(angle) * radius,
                        y + Math.cos(angle) * radius
                    );
                }
                starShape.lineTo(x, y + outerRadius);

                // Extrude settings
                const extrudeSettings = {
                    steps: 1,
                    depth: 1,
                    bevelEnabled: true,
                    bevelThickness: 0.1,
                    bevelSize: 0.1,
                    bevelOffset: 0,
                    bevelSegments: 3
                };

                const geometry = new THREE.ExtrudeGeometry(starShape, extrudeSettings);
                const material = new THREE.MeshStandardMaterial({
                    color: new THREE.Color(data.color || 0x808080),
                    roughness: data.roughness || 0.5,
                    metalness: data.metalness || 0,
                    side: THREE.DoubleSide
                });

                const mesh = new THREE.Mesh(geometry, material);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                return mesh;
            }
            performBooleanOperation(operation, objectA, objectB) {
                try {
                    // Clone objects to avoid modifying originals
                    const meshA = objectA.clone();
                    const meshB = objectB.clone();

                    // Preserve materials
                    meshA.material = objectA.material.clone();
                    meshB.material = objectB.material.clone();

                    // Convert to CSG
                    const bspA = new ThreeBSP(meshA);
                    const bspB = new ThreeBSP(meshB);

                    let resultBSP;
                    switch (operation) {
                        case 'union': resultBSP = bspA.union(bspB); break;
                        case 'difference': resultBSP = bspA.subtract(bspB); break;
                        case 'intersect': resultBSP = bspA.intersect(bspB); break;
                        default: throw new Error('Unknown boolean operation');
                    }

                    // Convert back to mesh
                    const resultMesh = resultBSP.toMesh(meshA.material);
                    resultMesh.position.copy(objectA.position);
                    resultMesh.rotation.copy(objectA.rotation);

                    // Clean up geometry
                    resultMesh.geometry.computeVertexNormals();

                    return resultMesh;
                } catch (error) {
                    console.error('Boolean operation failed:', error);
                    this.showNotification('Boolean operation failed - check mesh validity', 'error');
                    return null;
                }
            }

            performBooleanOnSelected(operation) {
                const selected = this.transformControls.object;
                if (!selected) return false;

                // Find the other selected object (assuming exactly two are selected)
                let otherObject = null;
                this.scene.traverse(child => {
                    if (child !== selected && child.userData && child.userData.selected) {
                        otherObject = child;
                    }
                });

                if (!otherObject) {
                    console.warn('Need exactly two selected objects for boolean operation');
                    return false;
                }

                // Perform the boolean operation
                const resultMesh = this.performBooleanOperation(operation, selected, otherObject);

                if (resultMesh) {
                    // Remove original objects
                    this.scene.remove(selected);
                    this.scene.remove(otherObject);

                    // Add the result
                    resultMesh.userData = {
                        id: selected.userData.id,
                        type: 'boolean-result',
                        name: `${operation}_result`
                    };

                    this.scene.add(resultMesh);
                    this.transformControls.attach(resultMesh);

                    return true;
                }

                return false;
            }
            createSphere(data) {
                const geometry = new THREE.SphereGeometry(0.5, 32, 32);
                const material = new THREE.MeshStandardMaterial({
                    color: new THREE.Color(data.color || 0x808080),
                    roughness: data.roughness || 0.5,
                    metalness: data.metalness || 0
                });

                const mesh = new THREE.Mesh(geometry, material);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                return mesh;
            }
            setupAnimationSystem() {
                this.mixer = new THREE.AnimationMixer(this.scene);
                this.animationClock = new THREE.Clock();


            }
            startAnimationLoop() {
                if (this.animationLoopRunning) return;

                this.animationLoopRunning = true;
                const animate = () => {
                    if (!this.animationLoopRunning) return;

                    requestAnimationFrame(animate);
                    const delta = this.animationClock.getDelta();

                    if (this.mixer) {
                        this.mixer.update(delta);
                    }

                    this.renderer.render(this.scene, this.camera);
                };

                animate();
            }

            stopAnimationLoop() {
                this.animationLoopRunning = false;
            }
            createCylinder(data) {
                const geometry = new THREE.CylinderGeometry(0.5, 0.5, 1, 32);
                const material = new THREE.MeshStandardMaterial({
                    color: new THREE.Color(data.color || 0x808080),
                    roughness: data.roughness || 0.5,
                    metalness: data.metalness || 0
                });

                const mesh = new THREE.Mesh(geometry, material);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                return mesh;
            }

            createCone(data) {
                const geometry = new THREE.ConeGeometry(0.5, 1, 32);
                const material = new THREE.MeshStandardMaterial({
                    color: new THREE.Color(data.color || 0x808080),
                    roughness: data.roughness || 0.5,
                    metalness: data.metalness || 0
                });

                const mesh = new THREE.Mesh(geometry, material);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                return mesh;
            }

            createTorus(data) {
                const geometry = new THREE.TorusGeometry(0.5, 0.2, 16, 32);
                const material = new THREE.MeshStandardMaterial({
                    color: new THREE.Color(data.color || 0x808080),
                    roughness: data.roughness || 0.5,
                    metalness: data.metalness || 0
                });

                const mesh = new THREE.Mesh(geometry, material);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                return mesh;
            }

            createPlane(data) {
                const geometry = new THREE.PlaneGeometry(5, 5);
                const material = new THREE.MeshStandardMaterial({
                    color: new THREE.Color(data.color || 0x808080),
                    roughness: data.roughness || 0.5,
                    metalness: data.metalness || 0,
                    side: THREE.DoubleSide
                });

                const mesh = new THREE.Mesh(geometry, material);
                mesh.rotation.x = -Math.PI / 2;
                mesh.receiveShadow = true;
                return mesh;
            }

            createLight(data) {
                const light = new THREE.PointLight(0xffffff, data.intensity || 1, data.distance || 10);
                light.castShadow = true;
                light.shadow.mapSize.width = 1024;
                light.shadow.mapSize.height = 1024;
                light.shadow.camera.near = 0.1;
                light.shadow.camera.far = data.distance || 10;
                return light;
            }

            createCamera(data) {
                const camera = new THREE.PerspectiveCamera(
                    75,
                    this.canvas.clientWidth / this.canvas.clientHeight,
                    0.1,
                    1000
                );
                return camera;
            }

            removeObject(objectId) {
                let removed = false;
                this.scene.traverse(child => {
                    if (child.userData.id === objectId) {
                        this.scene.remove(child);
                        if (child.userData.helper) {
                            this.scene.remove(child.userData.helper);
                        }
                        removed = true;
                    }
                });
                if (removed) this.updateStats();
                return removed;
            }

            getObject(objectId) {
                let result = null;
                this.scene.traverse(child => {
                    if (child.userData.id === objectId) {
                        result = child;
                    }
                });
                return result;
            }

            selectObject(objectId) {
                const object = this.getObject(objectId);
                if (object) {
                    this.selectionBox.setFromObject(object);
                    this.selectionBox.visible = true;
                    this.transformControls.attach(object);
                    this.transformControls.visible = true;
                    return true;
                }
                this.clearSelection();
                return false;
            }

            clearSelection() {
                this.selectionBox.visible = false;
                this.transformControls.detach();
                this.transformControls.visible = false;
            }

            setTransformMode(mode) {
                if (['translate', 'rotate', 'scale'].includes(mode)) {
                    this.transformControls.setMode(mode);
                    this.transformControls.visible = this.transformControls.object !== null;
                }
            }

            setupSculpting() {
                this.sculpting = {
                    active: false,
                    currentMesh: null,
                    originalPositions: null,
                    vertexNormals: null,
                    activeVertices: [],
                    lastCenter: null,
                    vertexGroups: new Map(),
                    symmetry: 'none',
                    history: [],
                    historyIndex: -1
                };

                this.brushPreview = new THREE.Mesh(
                    new THREE.SphereGeometry(1, 16, 16),
                    new THREE.MeshBasicMaterial({
                        color: 0x00ff00,
                        transparent: true,
                        opacity: 0.3,
                        wireframe: true
                    })
                );
                this.brushPreview.visible = false;
                this.scene.add(this.brushPreview);
            }

            getVerticesUnderBrush(mesh, point, radius) {
                if (!mesh.geometry) return [];

                const vertices = [];
                const geometry = mesh.geometry;
                const positionAttribute = geometry.getAttribute('position');
                const matrixWorld = mesh.matrixWorld;
                const inverseMatrix = new THREE.Matrix4().getInverse(matrixWorld);

                // Transform point to mesh local space
                const localPoint = point.clone().applyMatrix4(inverseMatrix);

                for (let i = 0; i < positionAttribute.count; i++) {
                    const vertex = new THREE.Vector3().fromBufferAttribute(positionAttribute, i);
                    const distance = vertex.distanceTo(localPoint);

                    if (distance <= radius) {
                        vertices.push({
                            index: i,
                            distance: distance,
                            originalPosition: vertex.clone(),
                            normal: this.getVertexNormal(mesh, i)
                        });
                    }
                }

                return vertices;
            }

            getVertexNormal(mesh, vertexIndex) {
                if (!mesh.geometry.attributes.normal) {
                    mesh.geometry.computeVertexNormals();
                }

                const normalAttribute = mesh.geometry.attributes.normal;
                return new THREE.Vector3().fromBufferAttribute(normalAttribute, vertexIndex);
            }

            setViewMode(mode) {
                this.scene.traverse(child => {
                    if (child.isMesh) {
                        switch (mode) {
                            case 'wireframe':
                                child.material.wireframe = true;
                                child.material.transparent = false;
                                child.material.opacity = 1;
                                break;
                            case 'solid':
                                child.material.wireframe = false;
                                child.material.transparent = false;
                                child.material.opacity = 1;
                                break;
                            case 'material':
                                child.material.wireframe = false;
                                child.material.transparent = false;
                                child.material.opacity = 1;
                                child.material.envMap = null;
                                child.material.lightMap = null;
                                child.material.emissiveMap = null;
                                break;
                            case 'rendered':
                                child.material.wireframe = false;
                                break;
                        }
                        child.material.needsUpdate = true;
                    }
                });
            }
            updateTransformControls() {
                if (this.transformControls.object) {
                    this.transformControls.update();
                }
            }

            setCameraView(view) {
                switch (view) {
                    case 'front':
                        this.camera.position.set(0, 0, 10);
                        this.camera.lookAt(0, 0, 0);
                        this.camera.up.set(0, 1, 0);
                        break;
                    case 'side':
                        this.camera.position.set(10, 0, 0);
                        this.camera.lookAt(0, 0, 0);
                        this.camera.up.set(0, 1, 0);
                        break;
                    case 'top':
                        this.camera.position.set(0, 10, 0);
                        this.camera.lookAt(0, 0, 0);
                        this.camera.up.set(0, 0, -1);
                        break;
                    case 'perspective':
                        this.camera.position.set(5, 5, 5);
                        this.camera.lookAt(0, 0, 0);
                        this.camera.up.set(0, 1, 0);
                        break;
                }
                this.controls.update();
            }

            updateStats() {
                this.stats.triangles = 0;
                this.stats.vertices = 0;
                this.stats.drawCalls = 0;

                this.scene.traverse(child => {
                    if (child.isMesh && child.geometry) {
                        if (child.geometry.index) {
                            this.stats.triangles += child.geometry.index.count / 3;
                        } else {
                            this.stats.triangles += child.geometry.attributes.position.count / 3;
                        }
                        this.stats.vertices += child.geometry.attributes.position.count;
                    }
                });
            }

            applyTexture(mesh, textureType, textureUrl) {
                if (!mesh || !mesh.material) return;

                const loader = new THREE.TextureLoader();
                loader.load(textureUrl, (texture) => {
                    texture.encoding = THREE.sRGBEncoding;

                    switch (textureType) {
                        case 'diffuse':
                            mesh.material.map = texture;
                            break;
                        case 'normal':
                            mesh.material.normalMap = texture;
                            break;
                        case 'roughness':
                            mesh.material.roughnessMap = texture;
                            break;
                    }
                    mesh.material.needsUpdate = true;
                });
            }
        }

        class UIManager {
            constructor(appState, sceneManager) {
                this.appState = appState;
                this.sceneManager = sceneManager;
                this.appState.activeTool = 'select';
                this.currentTextureType = 'diffuse';

                // Initialize with null values
                this.elements = {};

                // Cache elements safely
                this.cacheElements();
                this.initSculpting();
                // Initialize systems only if elements exist
                if (Object.keys(this.elements).length > 0) {
                    this.initTabSystem();
                    this.initMaterialEditor();
                    this.initEventListeners();
                    this.initPanelToggles();
                    this.initContextMenu();
                    this.initSculpting();
                    this.updateUI();
                } else {
                    console.error('Failed to cache UI elements');
                }
            }

            // Replace the cacheElements method in the UIManager class with this:
            cacheElements() {
                this.elements = {
                    canvas: document.getElementById('three-canvas'),
                    viewport: document.getElementById('viewport'),
                    welcomeScreen: document.getElementById('welcome-screen'),
                    sceneHierarchy: document.getElementById('scene-hierarchy'),
                    emptySceneMessage: document.getElementById('empty-scene-message'),
                    propertiesPanel: document.getElementById('properties-panel'),
                    noSelectionMessage: document.getElementById('no-selection-message'),
                    transformValues: document.getElementById('transform-values'),
                    materialPanel: document.getElementById('material-panel'),
                    objectCount: document.getElementById('object-count'),
                    triangleCount: document.getElementById('triangle-count'),
                    vertexCount: document.getElementById('vertex-count'),
                    fpsCounter: document.getElementById('fps-counter'),
                    statusMessage: document.getElementById('status-message'),
                    zoomLevel: document.getElementById('zoom-level'),
                    progressBar: document.getElementById('progress-bar'),
                    notification: document.getElementById('notification'),
                    notificationMessage: document.getElementById('notification-message'),
                    colorPicker: document.getElementById('color-picker-input'),
                    metallicSlider: document.getElementById('metallic-slider'),
                    metallicValue: document.getElementById('metallic-value'),
                    roughnessSlider: document.getElementById('roughness-slider'),
                    roughnessValue: document.getElementById('roughness-value'),
                    snapToggle: document.getElementById('snap-toggle'),
                    xAxisBtn: document.querySelector('[data-axis="x"]'),
                    yAxisBtn: document.querySelector('[data-axis="y"]'),
                    zAxisBtn: document.querySelector('[data-axis="z"]'),
                    diffuseMapBtn: document.getElementById('diffuse-map-btn'),
                    normalMapBtn: document.getElementById('normal-map-btn'),
                    roughnessMapBtn: document.getElementById('roughness-map-btn'),
                    clearDiffuseBtn: document.getElementById('clear-diffuse-btn'),
                    clearNormalBtn: document.getElementById('clear-normal-btn'),
                    clearRoughnessBtn: document.getElementById('clear-roughness-btn'),
                    imageInput: document.getElementById('image-input'),
                    timelinePanel: document.getElementById('timeline-panel'),
                    playBtn: document.getElementById('play-btn'),
                    pauseBtn: document.getElementById('pause-btn'),
                    stopBtn: document.getElementById('stop-btn'),
                    recordBtn: document.getElementById('record-btn'),
                    timeIndicator: document.getElementById('time-indicator'),
                    frameNumbers: document.getElementById('frame-numbers'),
                    playhead: document.getElementById('playhead'),
                    addKeyframeBtn: document.getElementById('add-keyframe-btn'),
                    zoomInBtn: document.getElementById('zoom-in-btn'),
                    zoomOutBtn: document.getElementById('zoom-out-btn'),
                    fitToViewBtn: document.getElementById('fit-to-view-btn'),
                    fpsInput: document.getElementById('fps-input'), // Added this line
                    startFrameInput: document.getElementById('start-frame-input'), // Added this line
                    endFrameInput: document.getElementById('end-frame-input'), // Added this line
                    timelineGrid: document.getElementById('timeline-grid'), // Added this line
                    tracksContent: document.getElementById('tracks-content') // Added this line
                };
                // Create hidden color input if it doesn't exist
                if (!this.elements.colorInput) {
                    this.elements.colorInput = document.getElementById('hidden-color-input') || document.createElement('input');
                    this.elements.colorInput.type = 'hidden';
                    this.elements.colorInput.id = 'hidden-color-input';
                    document.body.appendChild(this.elements.colorInput);
                }
            }

            initTabSystem() {
                const tabs = document.querySelectorAll('[data-tab]');
                const panels = document.querySelectorAll('.sculpting-panel');

                tabs.forEach(tab => {
                    tab.addEventListener('click', () => {
                        tabs.forEach(t => t.classList.remove('active'));
                        tab.classList.add('active');

                        const panelId = `${tab.dataset.tab}-panel`;
                        panels.forEach(panel => {
                            panel.style.display = panel.id === panelId ? 'block' : 'none';
                        });

                        // Set active tool when switching to sculpt tab
                        if (tab.dataset.tab === 'sculpt') {
                            this.appState.activeTool = 'sculpt';
                            this.updateToolButtons();
                        }
                    });
                });

                if (tabs.length > 0) tabs[0].click();
            }

            initMaterialEditor() {
                $(this.elements.colorPicker).spectrum({
                    color: "#808080",
                    preferredFormat: "hex",
                    showInput: true,
                    showAlpha: false,
                    allowEmpty: false,
                    change: (color) => {
                        this.elements.colorInput.value = color.toHexString();
                        this.updateSelectedMaterial();
                    }
                });

                this.elements.metallicSlider.addEventListener('input', (e) => {
                    this.elements.metallicValue.textContent = parseFloat(e.target.value).toFixed(2);
                    this.updateSelectedMaterial();
                });

                this.elements.roughnessSlider.addEventListener('input', (e) => {
                    this.elements.roughnessValue.textContent = parseFloat(e.target.value).toFixed(2);
                    this.updateSelectedMaterial();
                });
            }

            initEventListeners() {
                const toggleTimelineBtn = document.getElementById('toggle-timeline-btn');
                if (toggleTimelineBtn) {
                    toggleTimelineBtn.addEventListener('click', () => {
                        this.toggleTimeline();
                    });
                }

                const deleteTimelineBtn = document.getElementById('delete-timeline-btn');
                if (deleteTimelineBtn) {
                    deleteTimelineBtn.addEventListener('click', () => {
                        this.deleteTimeline();
                    });
                }
                // Tool buttons
                const selectToolBtn = document.getElementById('select-tool-btn');
                if (selectToolBtn) {
                    selectToolBtn.addEventListener('click', () => {
                        this.appState.activeTool = 'select';
                        this.sceneManager.transformControls.setMode('translate');
                        this.sceneManager.transformControls.enabled = false;
                        this.updateToolButtons();
                    });
                }

                // Similarly for other buttons - always check if element exists
                const translateToolBtn = document.getElementById('translate-tool-btn');
                if (translateToolBtn) {
                    translateToolBtn.addEventListener('click', () => {
                        this.appState.activeTool = 'translate';
                        this.sceneManager.transformControls.setMode('translate');
                        this.sceneManager.transformControls.enabled = true;
                        this.updateToolButtons();
                    });
                }
                // In the UIManager's initEventListeners method, add this:
                document.getElementById('sculpt-draw-btn').closest('.menu-item').addEventListener('click', () => {
                    this.appState.activeTool = 'sculpt';
                    this.updateToolButtons();
                    this.updateUI();
                });
                document.getElementById('rotate-tool-btn').addEventListener('click', () => {
                    this.appState.activeTool = 'rotate';
                    this.sceneManager.setTransformMode('rotate');
                    this.updateToolButtons();
                });

                document.getElementById('scale-tool-btn').addEventListener('click', () => {
                    this.appState.activeTool = 'scale';
                    this.sceneManager.setTransformMode('scale');
                    this.updateToolButtons();
                });

                // View mode buttons
                document.querySelectorAll('[data-view-mode]').forEach(btn => {
                    btn.addEventListener('click', () => {
                        this.appState.viewMode = btn.dataset.viewMode;
                        this.sceneManager.setViewMode(this.appState.viewMode);
                        this.updateViewModeButtons();
                    });
                });
                // Duplicate button
                document.getElementById('duplicate-btn').addEventListener('click', () => {
                    this.duplicateSelectedObjects();
                });

                // Camera view buttons
                document.querySelectorAll('[data-camera-view]').forEach(btn => {
                    btn.addEventListener('click', () => {
                        this.appState.cameraMode = btn.dataset.cameraView;
                        this.sceneManager.setCameraView(this.appState.cameraMode);
                        this.updateUI();
                    });
                });

                // Transform tabs
                document.querySelectorAll('[data-transform-tab]').forEach(tab => {
                    tab.addEventListener('click', () => {
                        this.appState.transformMode = tab.dataset.transformTab;
                        this.updateTransformTabs();
                        this.updateTransformInputs();
                    });
                });
                // Animation controls
                if (this.elements.playBtn) {
                    this.elements.playBtn.addEventListener('click', () => this.playAnimation());
                }
                this.elements.pauseBtn.addEventListener('click', () => this.pauseAnimation());
                this.elements.stopBtn.addEventListener('click', () => this.stopAnimation());
                this.elements.recordBtn.addEventListener('click', () => this.toggleRecording());
                this.elements.addKeyframeBtn.addEventListener('click', () => this.addKeyframeAtCurrentFrame());

                // Timeline navigation
                this.elements.zoomInBtn.addEventListener('click', () => this.zoomTimeline(1.2));
                this.elements.zoomOutBtn.addEventListener('click', () => this.zoomTimeline(0.8));
                this.elements.fitToViewBtn.addEventListener('click', () => this.fitTimelineToView());

                // Frame range controls
                if (this.elements.fpsInput) {
                    this.elements.fpsInput.addEventListener('change', (e) => {
                        this.appState.animation.fps = parseInt(e.target.value) || 24;
                    });
                }

                if (this.elements.startFrameInput) {
                    this.elements.startFrameInput.addEventListener('change', (e) => {
                        this.appState.animation.startFrame = parseInt(e.target.value) || 0;
                        if (this.appState.animation.currentFrame < this.appState.animation.startFrame) {
                            this.appState.animation.currentFrame = this.appState.animation.startFrame;
                        }
                        this.updateTimeline();
                    });
                }

                if (this.elements.endFrameInput) {
                    this.elements.endFrameInput.addEventListener('change', (e) => {
                        this.appState.animation.endFrame = parseInt(e.target.value) || 100;
                        if (this.appState.animation.currentFrame > this.appState.animation.endFrame) {
                            this.appState.animation.currentFrame = this.appState.animation.endFrame;
                        }
                        this.updateTimeline();
                    });
                }

                // Timeline click handler
                this.elements.timelineGrid.addEventListener('click', (e) => {
                    if (e.target === this.elements.timelineGrid) {
                        const rect = this.elements.timelineGrid.getBoundingClientRect();
                        const x = e.clientX - rect.left;
                        const frame = this.pixelToFrame(x);
                        this.setCurrentFrame(frame);
                    }
                });

                // Keyframe drag handling
                document.addEventListener('mousedown', (e) => {
                    const keyframe = e.target.closest('.keyframe');
                    if (keyframe) {
                        this.handleKeyframeDragStart(e, keyframe);
                    }
                });
                // Create shape buttons
                document.querySelectorAll('.create-shape').forEach(shape => {
                    shape.addEventListener('click', () => {
                        if (this.appState.activeTool === 'sculpt') {
                            this.appState.activeTool = 'select';
                            this.updateToolButtons();
                        }
                        this.stopAnimation(); // Only if needed and available
                        this.createObject(shape.dataset.shape);
                    });
                });


                // Sculpting tools
                this.elements.canvas.addEventListener('mousedown', (e) => {
                    if (this.appState.activeTool === 'sculpt') {
                        this.handleSculptStart(e);
                    } else {
                        this.handleCanvasMouseDown(e);
                    }
                });
                this.elements.canvas.addEventListener('mousemove', (e) => {
                    if (this.appState.activeTool === 'sculpt' && this.isSculpting) {
                        this.handleSculptMove(e);
                    } else {
                        this.handleCanvasMouseMove(e);
                    }
                });
                this.elements.canvas.addEventListener('mouseup', (e) => {
                    if (this.isSculpting) {
                        this.handleSculptEnd();
                    } else {
                        this.handleCanvasMouseUp(e);
                    }
                });


                document.getElementById('brush-size').addEventListener('input', (e) => {
                    this.appState.brushSettings.size = parseFloat(e.target.value);
                    document.getElementById('brush-size-value').textContent = e.target.value;
                });

                // Brush strength
                document.getElementById('brush-strength').addEventListener('input', (e) => {
                    this.appState.brushSettings.strength = parseFloat(e.target.value);
                    document.getElementById('brush-strength-value').textContent = e.target.value;
                });

                // Brush falloff
                document.getElementById('brush-falloff').addEventListener('input', (e) => {
                    this.appState.brushSettings.falloff = parseFloat(e.target.value);
                    document.getElementById('brush-falloff-value').textContent = e.target.value;
                });
                // Sculpt undo/redo
                document.getElementById('sculpt-undo-btn').addEventListener('click', () => {
                    if (this.appState.undo()) {
                        this.updateScene();
                        this.showNotification('Sculpt undo', 'success');
                    }
                });

                document.getElementById('sculpt-redo-btn').addEventListener('click', () => {
                    if (this.appState.redo()) {
                        this.updateScene();
                        this.showNotification('Sculpt redo', 'success');
                    }
                });
                // File operations
                document.getElementById('new-project-btn').addEventListener('click', () => {
                    this.newProject();
                });

                document.getElementById('open-project-btn').addEventListener('click', () => {
                    document.getElementById('file-input').click();
                });

                document.getElementById('export-scene-btn').addEventListener('click', async () => {
                    const sceneData = this.serializeSceneForExport();

                    try {
                        // Create a downloadable file
                        const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(sceneData));
                        const downloadAnchorNode = document.createElement('a');
                        downloadAnchorNode.setAttribute("href", dataStr);
                        downloadAnchorNode.setAttribute("download", "scene_export.json");
                        document.body.appendChild(downloadAnchorNode);
                        downloadAnchorNode.click();
                        downloadAnchorNode.remove();

                        this.showNotification('Export successful', 'success');
                    } catch (error) {
                        console.error('Export error:', error);
                        this.showNotification('Export failed', 'error');
                    }
                });
                // Edit operations
                document.getElementById('undo-btn').addEventListener('click', () => {
                    if (this.appState.undo()) {
                        this.updateScene();
                        this.showNotification('Undo successful', 'success');
                    } else {
                        this.showNotification('Nothing to undo', 'warning');
                    }
                });

                document.getElementById('redo-btn').addEventListener('click', () => {
                    if (this.appState.redo()) {
                        this.updateScene();
                        this.showNotification('Redo successful', 'success');
                    } else {
                        this.showNotification('Nothing to redo', 'warning');
                    }
                });

                document.getElementById('delete-btn').addEventListener('click', () => {
                    this.deleteSelectedObjects();
                });

                // Welcome screen buttons
                document.getElementById('add-cube-welcome-btn').addEventListener('click', () => {
                    this.createObject('box');
                });

                document.getElementById('open-project-welcome-btn').addEventListener('click', () => {
                    document.getElementById('file-input').click();
                });
                // Escape key to exit transform mode
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        this.appState.activeTool = 'select';
                        this.updateToolButtons();
                    }
                });
                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    // Ctrl+C or Cmd+C for copy
                    if ((e.ctrlKey || e.metaKey) && e.key === 'c') {
                        e.preventDefault();
                        this.duplicateSelectedObjects();
                    }

                    // Delete key for delete
                    if (e.key === 'Delete') {
                        e.preventDefault();
                        this.deleteSelectedObjects();
                    }
                });
                // Texture buttons
                this.elements.diffuseMapBtn.addEventListener('click', () => {
                    this.currentTextureType = 'diffuse';
                    this.elements.imageInput.click();
                });

                this.elements.normalMapBtn.addEventListener('click', () => {
                    this.currentTextureType = 'normal';
                    this.elements.imageInput.click();
                });

                this.elements.roughnessMapBtn.addEventListener('click', () => {
                    this.currentTextureType = 'roughness';
                    this.elements.imageInput.click();
                });

                this.elements.clearDiffuseBtn.addEventListener('click', () => {
                    this.clearTexture('diffuse');
                });

                this.elements.clearNormalBtn.addEventListener('click', () => {
                    this.clearTexture('normal');
                });

                this.elements.clearRoughnessBtn.addEventListener('click', () => {
                    this.clearTexture('roughness');
                });

                // Image input handler
                this.elements.imageInput.addEventListener('change', (e) => {
                    if (e.target.files.length > 0) {
                        this.applyTextureToSelected(e.target.files[0]);
                    }
                });
                // Boolean operation buttons
                document.getElementById('boolean-union-btn').addEventListener('click', () => {
                    if (this.sceneManager.performBooleanOnSelected('union')) {
                        this.showNotification('Union operation applied', 'success');
                    } else {
                        this.showNotification('Select exactly two objects for boolean operation', 'warning');
                    }
                });

                document.getElementById('boolean-difference-btn').addEventListener('click', () => {
                    if (this.sceneManager.performBooleanOnSelected('difference')) {
                        this.showNotification('Difference operation applied', 'success');
                    } else {
                        this.showNotification('Select exactly two objects for boolean operation', 'warning');
                    }
                });

                document.getElementById('boolean-intersect-btn').addEventListener('click', () => {
                    if (this.sceneManager.performBooleanOnSelected('intersect')) {
                        this.showNotification('Intersection operation applied', 'success');
                    } else {
                        this.showNotification('Select exactly two objects for boolean operation', 'warning');
                    }
                });
                // Snap settings
                if (this.elements.snapToggle) {
                    this.elements.snapToggle.addEventListener('change', (e) => {
                        this.appState.snapSettings.enabled = e.target.checked;
                    });
                }

                // Axis constraints
                if (this.elements.xAxisBtn) {
                    this.elements.xAxisBtn.addEventListener('click', () => {
                        this.appState.toggleAxisConstraint('x');
                        this.updateAxisConstraintButtons();
                    });
                }

                if (this.elements.yAxisBtn) {
                    this.elements.yAxisBtn.addEventListener('click', () => {
                        this.appState.toggleAxisConstraint('y');
                        this.updateAxisConstraintButtons();
                    });
                }

                if (this.elements.zAxisBtn) {
                    this.elements.zAxisBtn.addEventListener('click', () => {
                        this.appState.toggleAxisConstraint('z');
                        this.updateAxisConstraintButtons();
                    });
                }

                // Canvas event listeners
                this.elements.canvas.addEventListener('mousedown', (e) => this.handleCanvasMouseDown(e));
                this.elements.canvas.addEventListener('mousemove', (e) => this.handleCanvasMouseMove(e));
                this.elements.canvas.addEventListener('mouseup', (e) => this.handleCanvasMouseUp(e));
                this.elements.canvas.addEventListener('click', (e) => this.handleCanvasClick(e));

                // Transform input changes
                this.elements.transformValues.querySelectorAll('input').forEach(input => {
                    input.addEventListener('change', () => this.handleTransformInputChange());
                });

                // Window resize
                window.addEventListener('resize', () => {
                    this.sceneManager.resize();
                });
            }

            serializeSceneForExport() {
                const exportData = {
                    metadata: {
                        version: "1.0",
                        generator: "Olmec 3D Editor",
                        date: new Date().toISOString()
                    },
                    scene: this.appState.serializeState(),
                    objects: [],
                    materials: [],
                    animations: this.appState.animation
                };

                // Serialize all objects in the scene
                this.sceneManager.scene.traverse(child => {
                    if (child.userData && child.userData.id) {
                        const objData = {
                            id: child.userData.id,
                            type: child.userData.type,
                            name: child.userData.name,
                            position: child.position.toArray(),
                            rotation: child.rotation.toArray(),
                            scale: child.scale.toArray(),
                            visible: child.visible,
                            userData: child.userData
                        };

                        if (child.isMesh && child.material) {
                            objData.material = {
                                color: child.material.color.getHex(),
                                roughness: child.material.roughness,
                                metalness: child.material.metalness,
                                map: child.material.map ? 'texture_' + child.material.map.uuid : null,
                                normalMap: child.material.normalMap ? 'texture_' + child.material.normalMap.uuid : null,
                                roughnessMap: child.material.roughnessMap ? 'texture_' + child.material.roughnessMap.uuid : null
                            };
                        }

                        exportData.objects.push(objData);
                    }
                });

                // Include textures if needed
                exportData.textures = this.appState.textures;

                return exportData;
            }
            initPanelToggles() {
                // Left panel toggle
                document.getElementById('left-panel-toggle').addEventListener('click', () => {
                    const leftPanel = document.querySelector('aside:first-child');
                    const toggleBtn = document.getElementById('left-panel-toggle');

                    leftPanel.classList.toggle('collapsed');
                    if (leftPanel.classList.contains('collapsed')) {
                        toggleBtn.innerHTML = '<i class="fas fa-chevron-right"></i>';
                        toggleBtn.style.right = '-16px';
                    } else {
                        toggleBtn.innerHTML = '<i class="fas fa-chevron-left"></i>';
                    }
                    this.sceneManager.resize();
                });

                // Right panel toggle
                document.getElementById('right-panel-toggle').addEventListener('click', () => {
                    const rightPanel = document.querySelector('aside:last-child');
                    const toggleBtn = document.getElementById('right-panel-toggle');

                    rightPanel.classList.toggle('collapsed');
                    if (rightPanel.classList.contains('collapsed')) {
                        toggleBtn.innerHTML = '<i class="fas fa-chevron-left"></i>';
                        toggleBtn.style.left = '-16px';
                    } else {
                        toggleBtn.innerHTML = '<i class="fas fa-chevron-right"></i>';
                    }
                    this.sceneManager.resize();
                });
            }
            // Add these new methods to the UIManager class:
            toggleTimeline() {
                const timelinePanel = document.getElementById('timeline-panel');
                timelinePanel.classList.toggle('hidden');
                this.showNotification(
                    timelinePanel.classList.contains('hidden') ?
                        'Timeline hidden' : 'Timeline shown',
                    'info'
                );
            }
            initAnimationControls() {
                if (!this.elements.timeline || !this.elements.timelineGrid) {
                    console.error('Timeline elements not found');
                    return;
                }
                // Play/pause/stop buttons
                this.elements.playBtn.addEventListener('click', () => {
                    if (this.currentAction) {
                        this.currentAction.play();
                        this.appState.animation.isPlaying = true;
                    }
                });

                this.elements.pauseBtn.addEventListener('click', () => {
                    if (this.currentAction) {
                        this.currentAction.paused = true;
                        this.appState.animation.isPlaying = false;
                    }
                });

                this.elements.stopBtn.addEventListener('click', () => {
                    if (this.currentAction) {
                        this.currentAction.stop();
                        this.appState.animation.isPlaying = false;
                        this.resetAnimationToStart();
                    }
                });

                // Timeline scrubbing
                this.elements.timeline.addEventListener('input', (e) => {
                    const progress = parseFloat(e.target.value);
                    if (this.currentAction) {
                        this.currentAction.time = progress * this.currentAction.getClip().duration;
                        this.currentAction.paused = true;
                    }
                });
            }

            deleteTimeline() {
                if (confirm('Are you sure you want to delete the entire timeline? This cannot be undone.')) {
                    const timelinePanel = document.getElementById('timeline-panel');
                    timelinePanel.remove();
                    this.showNotification('Timeline deleted', 'success');

                    // You might want to add a method to recreate it later
                    // For now, we'll just hide the toggle button
                    document.getElementById('toggle-timeline-btn').classList.add('hidden');
                }
            }
            playAnimation() {
                this.appState.animation.isPlaying = true;
                this.appState.animation.isRecording = false;
                this.sceneManager.startAnimationLoop();
                this.updateAnimationControls();
            }

            pauseAnimation() {
                this.appState.animation.isPlaying = false;
                this.updateAnimationControls();
            }

            stopAnimation() {
                this.appState.animation.isPlaying = false;
                this.appState.animation.currentFrame = this.appState.animation.startFrame;
                this.appState.applyAnimation(this.appState.animation.currentFrame);
                this.updateAnimationControls();
                this.updateTimeline();

            }

            toggleRecording() {
                this.appState.animation.isRecording = !this.appState.animation.isRecording;
                this.updateAnimationControls();
            }

            updateAnimationControls() {
                this.elements.playBtn.classList.toggle('active', this.appState.animation.isPlaying && !this.appState.animation.isRecording);
                this.elements.pauseBtn.classList.toggle('active', !this.appState.animation.isPlaying);
                this.elements.recordBtn.classList.toggle('active', this.appState.animation.isRecording);

                if (this.appState.animation.isRecording) {
                    this.elements.recordBtn.innerHTML = '<i class="fas fa-circle text-red-500"></i> Recording';
                } else {
                    this.elements.recordBtn.innerHTML = '<i class="fas fa-circle text-red-500"></i>';
                }
            }

            updateTimeline() {
                // Clear existing elements
                this.elements.tracksContent.innerHTML = '';

                // Add tracks for each animated property
                Object.entries(this.appState.animation.tracks).forEach(([objectId, properties]) => {
                    const obj = this.sceneManager.getObject(objectId);
                    if (!obj) return;

                    Object.entries(properties).forEach(([property, keyframes]) => {
                        const trackElement = document.createElement('div');
                        trackElement.className = 'track h-8 relative border-b border-gray-700';

                        keyframes.forEach(kf => {
                            const keyframeElement = document.createElement('div');
                            keyframeElement.className = `keyframe ${property} absolute top-1/2 w-3 h-3 rounded-full -ml-1.5 -mt-1.5`;
                            keyframeElement.style.left = `${this.frameToPixel(kf.frame)}px`;
                            keyframeElement.dataset.objectId = objectId;
                            keyframeElement.dataset.property = property;
                            keyframeElement.dataset.frame = kf.frame;

                            trackElement.appendChild(keyframeElement);
                        });

                        this.elements.tracksContent.appendChild(trackElement);
                    });
                });

                this.updatePlayhead();
                this.updateFrameNumbers();
            }

            updateFrameNumbers() {
                const frameNumbers = this.elements.frameNumbers;
                frameNumbers.innerHTML = '';

                const frameWidth = 40 * this.appState.animation.zoomLevel;
                const visibleFrames = Math.ceil(this.elements.timelineGrid.clientWidth / frameWidth);
                const startFrame = Math.max(0, Math.floor(this.appState.animation.currentFrame - visibleFrames / 2));
                const endFrame = Math.min(this.appState.animation.endFrame, startFrame + visibleFrames);

                for (let i = startFrame; i <= endFrame; i++) {
                    if (i % 5 === 0 || i === startFrame || i === endFrame) {
                        const frameElement = document.createElement('div');
                        frameElement.textContent = i;
                        frameElement.style.width = `${frameWidth}px`;
                        frameNumbers.appendChild(frameElement);
                    }
                }
            }


            updatePlayhead() {
                const frameWidth = 40 * this.appState.animation.zoomLevel;
                const position = (this.appState.animation.currentFrame - this.appState.animation.startFrame) * frameWidth;
                this.elements.playhead.style.left = `${position}px`;
            }

            updateKeyframeDisplay() {
                const tracksContainer = document.getElementById('tracks-content');
                tracksContainer.innerHTML = '';

                Object.keys(this.appState.animation.tracks).forEach(objectId => {
                    const obj = this.appState.getObject(objectId);
                    if (!obj) return;

                    const tracks = this.appState.animation.tracks[objectId];
                    Object.keys(tracks).forEach(property => {
                        const trackElement = document.createElement('div');
                        trackElement.className = 'track h-8 relative border-b border-gray-700';

                        const keyframes = tracks[property];
                        keyframes.forEach(kf => {
                            const keyframeElement = document.createElement('div');
                            keyframeElement.className = `keyframe ${property} absolute top-1/2 w-2 h-2 rounded-full -ml-1 -mt-1`;
                            keyframeElement.style.left = `${this.frameToPixel(kf.frame)}px`;
                            keyframeElement.dataset.objectId = objectId;
                            keyframeElement.dataset.property = property;
                            keyframeElement.dataset.frame = kf.frame;

                            trackElement.appendChild(keyframeElement);
                        });

                        tracksContainer.appendChild(trackElement);
                    });
                });
            }
            updateTimeIndicator() {
                const frame = this.appState.animation.currentFrame;
                const fps = this.appState.animation.fps;
                const seconds = frame / fps;
                const minutes = Math.floor(seconds / 60);
                const remainingSeconds = Math.floor(seconds % 60);
                const frames = frame % fps;

                const totalSeconds = this.appState.animation.endFrame / fps;
                const totalMinutes = Math.floor(totalSeconds / 60);
                const totalRemainingSeconds = Math.floor(totalSeconds % 60);

                this.elements.timeIndicator.textContent =
                    `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}:${frames.toString().padStart(2, '0')} / ` +
                    `${totalMinutes.toString().padStart(2, '0')}:${totalRemainingSeconds.toString().padStart(2, '0')}:00`;
            }

            // Add these helper methods
            pixelToFrame(pixelX) {
                const frameWidth = 40 * this.appState.animation.zoomLevel;
                return Math.round(pixelX / frameWidth) + this.appState.animation.startFrame;
            }

            frameToPixel(frame) {
                const frameWidth = 40 * this.appState.animation.zoomLevel;
                return (frame - this.appState.animation.startFrame) * frameWidth;
            }

            setCurrentFrame(frame) {
                frame = Math.max(this.appState.animation.startFrame,
                    Math.min(this.appState.animation.endFrame, frame));

                if (this.appState.animation.snapToFrames) {
                    frame = Math.round(frame);
                }

                this.appState.animation.currentFrame = frame;
                this.appState.applyAnimation(frame);
                this.updateTimeline();
            }

            zoomTimeline(factor) {
                this.appState.animation.zoomLevel *= factor;
                this.appState.animation.zoomLevel = Math.max(0.1, Math.min(5, this.appState.animation.zoomLevel));
                this.updateTimeline();
            }

            fitTimelineToView() {
                const containerWidth = this.elements.timelineGrid.clientWidth;
                const totalFrames = this.appState.animation.endFrame - this.appState.animation.startFrame;
                const desiredFrameWidth = containerWidth / totalFrames;
                this.appState.animation.zoomLevel = desiredFrameWidth / 40;
                this.updateTimeline();
            }

            // Add these keyframe methods
            addKeyframeAtCurrentFrame() {
                const frame = Math.round(this.appState.animation.currentFrame);
                const selectedObjects = this.appState.getSelectedObjects();

                if (selectedObjects.length === 0) {
                    this.showNotification('No objects selected', 'warning');
                    return;
                }

                selectedObjects.forEach(obj => {
                    const threeObj = this.sceneManager.getObject(obj.id);
                    if (!threeObj) return;

                    // Add keyframes for transform properties
                    this.appState.addKeyframe(
                        obj.id,
                        'position',
                        frame,
                        [threeObj.position.x, threeObj.position.y, threeObj.position.z]
                    );

                    this.appState.addKeyframe(
                        obj.id,
                        'rotation',
                        frame,
                        [threeObj.rotation.x, threeObj.rotation.y, threeObj.rotation.z]
                    );

                    this.appState.addKeyframe(
                        obj.id,
                        'scale',
                        frame,
                        [threeObj.scale.x, threeObj.scale.y, threeObj.scale.z]
                    );
                });

                this.updateTimeline();
                this.showNotification('Keyframes added', 'success');
            }

            handleKeyframeDragStart(e, keyframeElement) {
                e.preventDefault();
                e.stopPropagation();

                const objectId = keyframeElement.dataset.objectId;
                const property = keyframeElement.dataset.property;
                const frame = parseInt(keyframeElement.dataset.frame);

                // Select keyframe
                if (!e.ctrlKey && !e.metaKey) {
                    this.appState.animation.selectedKeyframes = [];
                }

                this.appState.animation.selectedKeyframes.push({
                    objectId,
                    property,
                    frame
                });

                this.updateTimeline();

                // Setup drag
                const startX = e.clientX;
                const startFrame = frame;

                const handleDragMove = (moveEvent) => {
                    const deltaX = moveEvent.clientX - startX;
                    const frameDelta = Math.round(deltaX / (40 * this.appState.animation.zoomLevel));
                    const newFrame = startFrame + frameDelta;

                    if (this.appState.animation.snapToFrames) {
                        keyframeElement.dataset.frame = Math.round(newFrame);
                    } else {
                        keyframeElement.dataset.frame = newFrame;
                    }

                    keyframeElement.style.left = `${this.frameToPixel(newFrame)}px`;
                };

                const handleDragEnd = () => {
                    document.removeEventListener('mousemove', handleDragMove);
                    document.removeEventListener('mouseup', handleDragEnd);

                    const newFrame = parseInt(keyframeElement.dataset.frame);
                    if (newFrame !== frame) {
                        // Update keyframe in state
                        const tracks = this.appState.animation.tracks[objectId][property];
                        const keyframe = tracks.find(kf => kf.frame === frame);
                        if (keyframe) {
                            keyframe.frame = newFrame;
                            tracks.sort((a, b) => a.frame - b.frame);
                            this.appState.saveHistory();
                        }
                    }
                };

                document.addEventListener('mousemove', handleDragMove);
                document.addEventListener('mouseup', handleDragEnd);
            }

            duplicateSelectedObjects() {
                const copies = this.appState.copySelectedObjects();
                if (!copies || copies.length === 0) {
                    this.showNotification('No objects selected to duplicate', 'warning');
                    return;
                }

                // Add the copies to the scene
                copies.forEach(copy => {
                    this.appState.addObject(copy);
                    this.sceneManager.duplicateObject(copy);
                });

                // Select the new copies
                this.appState.clearSelection();
                copies.forEach(copy => {
                    this.appState.selectObject(copy.id, true);
                });

                this.updateUI();
                this.showNotification(`${copies.length} object(s) duplicated`, 'success');
            }

            // Update in UIManager class
            initSculpting() {
                this.isSculpting = false;
                this.lastMousePosition = null;

                // Sculpt tool buttons
                // Sculpt tool buttons
                document.querySelectorAll('.sculpt-tool').forEach(tool => {
                    tool.addEventListener('click', () => {
                        this.appState.activeTool = 'sculpt'; // Ensure this is set
                        this.appState.sculpting.currentTool = tool.dataset.tool;
                        this.updateSculptTools();
                        this.updateToolButtons(); // Update the main toolbar buttons
                    });
                });

                // Brush settings
                document.getElementById('brush-size').addEventListener('input', (e) => {
                    this.appState.brushSettings.size = parseFloat(e.target.value);
                    document.getElementById('brush-size-value').textContent = e.target.value;
                });

                document.getElementById('brush-strength').addEventListener('input', (e) => {
                    this.appState.brushSettings.strength = parseFloat(e.target.value);
                    document.getElementById('brush-strength-value').textContent = e.target.value;
                });

                document.getElementById('brush-falloff').addEventListener('input', (e) => {
                    this.appState.brushSettings.falloff = parseFloat(e.target.value);
                    document.getElementById('brush-falloff-value').textContent = e.target.value;
                });

                document.getElementById('brush-symmetry').addEventListener('change', (e) => {
                    this.appState.brushSettings.symmetry = e.target.value;
                });
            }

            handleSculptStart(e) {
                if (this.appState.activeTool !== 'sculpt') return;

                this.sceneManager.mouse.x = (e.clientX / this.elements.canvas.clientWidth) * 2 - 1;
                this.sceneManager.mouse.y = -(e.clientY / this.elements.canvas.clientHeight) * 2 + 1;

                const intersection = this.sceneManager.getMeshUnderPointer(this.sceneManager.mouse);

                if (intersection && intersection.object.isMesh) {
                    this.isSculpting = true;
                    this.lastMousePosition = { x: e.clientX, y: e.clientY };

                    // Prepare the mesh for sculpting
                    this.sceneManager.prepareMeshForSculpting(intersection.object);
                    this.sceneManager.sculpting.currentMesh = intersection.object;
                    this.showNotification(`Ready to sculpt ${intersection.object.userData.name}`, 'info');
                    this.sceneManager.sculpting.currentMesh = intersection.object;
                    this.sceneManager.sculpting.lastCenter = intersection.point;

                    // Get vertices in brush radius
                    const vertices = this.sceneManager.getVerticesUnderBrush(
                        intersection.object,
                        intersection.point,
                        this.appState.brushSettings.size
                    );

                    // Store initial state
                    this.sceneManager.sculpting.activeVertices = vertices;

                    // Show brush preview
                    this.sceneManager.updateBrushPreview(
                        intersection.point,
                        this.appState.brushSettings.size
                    );
                }
            }
            handleSculptMove(e) {
                if (!this.isSculpting || !this.sceneManager.sculpting.currentMesh) return;

                this.sceneManager.mouse.x = (e.clientX / this.elements.canvas.clientWidth) * 2 - 1;
                this.sceneManager.mouse.y = -(e.clientY / this.elements.canvas.clientHeight) * 2 + 1;

                const intersection = this.sceneManager.getMeshUnderPointer(this.sceneManager.mouse);
                if (intersection && intersection.object === this.sceneManager.sculpting.currentMesh) {
                    const currentMousePos = { x: e.clientX, y: e.clientY };
                    const delta = {
                        x: currentMousePos.x - this.lastMousePosition.x,
                        y: currentMousePos.y - this.lastMousePosition.y
                    };

                    // Apply brush effect
                    this.sceneManager.applyBrushEffect(
                        this.sceneManager.sculpting.currentMesh,
                        this.sceneManager.sculpting.activeVertices,
                        intersection.point,
                        intersection.face.normal,
                        this.appState.brushSettings.strength * 0.01, // Scale down strength
                        this.appState.sculpting.currentTool
                    );

                    this.lastMousePosition = currentMousePos;
                    this.sceneManager.sculpting.lastCenter = intersection.point;

                    // Update brush preview
                    this.sceneManager.updateBrushPreview(
                        intersection.point,
                        this.appState.brushSettings.size
                    );
                }
            }


            handleSculptEnd() {
                if (this.isSculpting) {
                    this.isSculpting = false;
                    this.appState.saveHistory();
                    this.sceneManager.sculpting.currentMesh = null;
                    this.sceneManager.sculpting.activeVertices = null;
                    this.sceneManager.sculpting.lastCenter = null;
                    this.sceneManager.hideBrushPreview();
                    this.appState.saveHistory();
                    this.showNotification('Sculpting complete', 'success');
                }
            }
            initContextMenu() {
                const contextMenu = document.getElementById('context-menu');

                document.getElementById('context-add-object').addEventListener('click', () => {
                    this.createObject('box');
                    contextMenu.classList.add('hidden');
                });

                document.getElementById('context-select-all').addEventListener('click', () => {
                    this.selectAllObjects();
                    contextMenu.classList.add('hidden');
                });

                document.getElementById('context-group').addEventListener('click', () => {
                    this.groupSelectedObjects();
                    contextMenu.classList.add('hidden');
                });

                document.getElementById('context-ungroup').addEventListener('click', () => {
                    this.ungroupSelectedObjects();
                    contextMenu.classList.add('hidden');
                });

                document.getElementById('context-hide').addEventListener('click', () => {
                    this.toggleSelectedObjectsVisibility();
                    contextMenu.classList.add('hidden');
                });

                document.getElementById('context-freeze').addEventListener('click', () => {
                    this.toggleSelectedObjectsFreeze();
                    contextMenu.classList.add('hidden');
                });

                // Show context menu on right-click
                this.elements.canvas.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    contextMenu.style.left = `${e.clientX}px`;
                    contextMenu.style.top = `${e.clientY}px`;
                    contextMenu.classList.remove('hidden');
                });

                // Hide context menu on click elsewhere
                document.addEventListener('click', () => {
                    contextMenu.classList.add('hidden');
                });
            }

            updateUI() {
                this.updateSceneHierarchy();
                this.updatePropertiesPanel();
                this.updateToolButtons();
                this.updateViewModeButtons();
                this.updateTransformTabs();
                this.updateTransformInputs();
                this.updateSculptTools();
                this.updateAxisConstraintButtons();
                this.updateStats();
                this.updateWelcomeScreen();
                this.updateTimeline();
                this.updateAnimationControls();
                const sculptIndicator = document.getElementById('sculpt-mode-indicator');
                if (sculptIndicator) {
                    sculptIndicator.style.display = this.appState.activeTool === 'sculpt' ? 'block' : 'none';
                }
            }

            updateSceneHierarchy() {
                const sceneHierarchy = this.elements.sceneHierarchy;
                sceneHierarchy.innerHTML = '';

                this.appState.sceneObjects.forEach(obj => {
                    const item = document.createElement('li');
                    item.className = 'scene-item';
                    if (this.appState.selectedObjects.includes(obj.id)) {
                        item.classList.add('selected');
                    }

                    item.innerHTML = `
                <div class="flex items-center">
                    <i class="fas fa-${this.getObjectIcon(obj.type)} mr-2"></i>
                    <span class="text-sm">${obj.name || `${obj.type}_${obj.id}`}</span>
                </div>
            `;

                    item.addEventListener('click', (e) => {
                        const multiSelect = e.ctrlKey || e.metaKey;
                        this.selectObjectInScene(obj.id, multiSelect);
                    });

                    sceneHierarchy.appendChild(item);
                });

                this.elements.emptySceneMessage.style.display =
                    this.appState.sceneObjects.length === 0 ? 'block' : 'none';
            }

            updatePropertiesPanel() {
                const selectedObjects = this.appState.getSelectedObjects();
                const panel = this.elements.propertiesPanel;

                if (selectedObjects.length === 0) {
                    this.elements.noSelectionMessage.style.display = 'block';
                    panel.innerHTML = '';
                    return;
                }

                this.elements.noSelectionMessage.style.display = 'none';

                // For simplicity, we'll just show properties of the first selected object
                const obj = selectedObjects[0];
                panel.innerHTML = `
            <div class="space-y-4">
                <div>
                    <label class="block text-xs text-gray-400 mb-2">Name</label>
                    <input type="text" value="${obj.name || `${obj.type}_${obj.id}`}" 
                        class="property-input w-full px-3 py-2 rounded-lg text-sm">
                </div>
                <div>
                    <label class="block text-xs text-gray-400 mb-2">Type</label>
                    <div class="glass px-3 py-2 rounded-lg text-sm">${obj.type}</div>
                </div>
                ${obj.type === 'light' ? `
                <div>
                    <label class="block text-xs text-gray-400 mb-2">Intensity</label>
                    <input type="range" min="0" max="10" step="0.1" value="${obj.intensity || 1}" 
                        class="w-full" id="light-intensity">
                </div>
                ` : ''}
            </div>
        `;

                // Add event listeners for dynamic properties
                if (obj.type === 'light') {
                    panel.querySelector('#light-intensity').addEventListener('input', (e) => {
                        const threeObj = this.sceneManager.getObject(obj.id);
                        if (threeObj) {
                            threeObj.intensity = parseFloat(e.target.value);
                        }
                    });
                }
            }
            updateToolButtons() {
                const tools = ['select', 'translate', 'rotate', 'scale', 'sculpt'];
                tools.forEach(tool => {
                    const btn = document.getElementById(`${tool}-tool-btn`);
                    if (btn) {
                        if (tool === this.appState.activeTool) {
                            btn.classList.add('active');
                        } else {
                            btn.classList.remove('active');
                        }
                    }
                });

                // Ensure select tool is active by default
                if (!this.appState.activeTool) {
                    this.appState.activeTool = 'select';
                    document.getElementById('select-tool-btn').classList.add('active');
                }

                // Properly manage transform controls
                if (this.appState.activeTool === 'select' || this.appState.activeTool === 'sculpt') {
                    this.sceneManager.transformControls.detach();
                    this.sceneManager.transformControls.enabled = false;
                } else {
                    this.sceneManager.transformControls.setMode(this.appState.activeTool);
                    this.sceneManager.transformControls.enabled = true;

                    // Re-attach to selected object if one exists
                    const selectedObjects = this.appState.getSelectedObjects();
                    if (selectedObjects.length > 0) {
                        const threeObj = this.sceneManager.getObject(selectedObjects[0].id);
                        if (threeObj) {
                            this.sceneManager.transformControls.attach(threeObj);
                        }
                    }
                }
            }

            updateViewModeButtons() {
                document.querySelectorAll('[data-view-mode]').forEach(btn => {
                    btn.addEventListener('click', () => {
                        this.appState.viewMode = btn.dataset.viewMode;
                        this.sceneManager.setViewMode(this.appState.viewMode);
                        this.updateViewModeButtons();
                    });
                });
                document.querySelectorAll('[data-camera-view]').forEach(btn => {
                    btn.addEventListener('click', () => {
                        this.appState.cameraMode = btn.dataset.cameraView;
                        this.sceneManager.setCameraView(this.appState.cameraMode);
                        this.updateUI();
                    });
                });
            }

            updateTransformTabs() {
                document.querySelectorAll('[data-transform-tab]').forEach(tab => {
                    if (tab.dataset.transformTab === this.appState.transformMode) {
                        tab.classList.add('active');
                    } else {
                        tab.classList.remove('active');
                    }
                });
            }

            updateTransformInputs() {
                const selectedObjects = this.appState.getSelectedObjects();
                if (selectedObjects.length === 0) return;

                // For simplicity, we'll just use the first selected object
                const obj = this.sceneManager.getObject(selectedObjects[0].id);
                if (!obj) return;

                const inputs = this.elements.transformValues.querySelectorAll('input');

                if (this.appState.transformMode === 'location') {
                    inputs[0].value = obj.position.x.toFixed(3);
                    inputs[1].value = obj.position.y.toFixed(3);
                    inputs[2].value = obj.position.z.toFixed(3);
                } else if (this.appState.transformMode === 'rotation') {
                    inputs[0].value = THREE.MathUtils.radToDeg(obj.rotation.x).toFixed(3);
                    inputs[1].value = THREE.MathUtils.radToDeg(obj.rotation.y).toFixed(3);
                    inputs[2].value = THREE.MathUtils.radToDeg(obj.rotation.z).toFixed(3);
                } else if (this.appState.transformMode === 'scale') {
                    inputs[0].value = obj.scale.x.toFixed(3);
                    inputs[1].value = obj.scale.y.toFixed(3);
                    inputs[2].value = obj.scale.z.toFixed(3);
                }
            }
            updateSculptTools() {
                document.querySelectorAll('.sculpt-tool').forEach(tool => {
                    tool.classList.toggle('active',
                        tool.dataset.tool === this.appState.sculpting.currentTool);
                });

                if (this.appState.activeTool === 'sculpt') {
                    this.showNotification(`Sculpt tool: ${this.appState.sculpting.currentTool}`, 'info');
                }
            }

            updateAxisConstraintButtons() {
                const constraints = this.appState.snapSettings.axisConstraints;
                this.elements.xAxisBtn.classList.toggle('active', constraints.x);
                this.elements.yAxisBtn.classList.toggle('active', constraints.y);
                this.elements.zAxisBtn.classList.toggle('active', constraints.z);
            }

            updateStats() {
                this.elements.objectCount.textContent = `Objects: ${this.appState.sceneObjects.length}`;
                this.elements.triangleCount.textContent = `Triangles: ${this.sceneManager.stats.triangles}`;
                this.elements.vertexCount.textContent = `Vertices: ${this.sceneManager.stats.vertices}`;
                this.elements.fpsCounter.textContent = `FPS: ${this.appState.performance.fps}`;
            }

            updateWelcomeScreen() {
                this.elements.welcomeScreen.style.display =
                    this.appState.sceneObjects.length === 0 ? 'flex' : 'none';
            }

            updateSelectedMaterial() {
                const selectedObjects = this.appState.getSelectedObjects();
                if (selectedObjects.length === 0) return;

                const color = new THREE.Color(this.elements.colorInput.value);
                const metallic = parseFloat(this.elements.metallicSlider.value);
                const roughness = parseFloat(this.elements.roughnessSlider.value);

                selectedObjects.forEach(obj => {
                    const threeObj = this.sceneManager.getObject(obj.id);
                    if (threeObj && threeObj.material) {
                        threeObj.material.color.copy(color);
                        threeObj.material.metalness = metallic;
                        threeObj.material.roughness = roughness;
                        threeObj.material.needsUpdate = true;
                    }
                });

                this.appState.saveHistory(); // Save state after material change
            }

            getObjectIcon(type) {
                const icons = {
                    box: 'cube',
                    sphere: 'globe',
                    cylinder: 'database',
                    cone: 'concierge-bell',
                    torus: 'ring',
                    plane: 'square',
                    light: 'lightbulb',
                    camera: 'camera'
                };
                return icons[type] || 'cube';
            }

            handleCanvasMouseDown(e) {
                if (e.button !== 0) return; // Only left mouse button
                // Check for sculpt mode first
                if (this.appState.activeTool === 'sculpt') {
                    this.handleSculptStart(e);
                    return;
                }
                this.appState.isDragging = true;
                this.appState.dragStart = {
                    x: e.clientX,
                    y: e.clientY
                };

                // For selection box
                if (this.appState.activeTool === 'select' && !e.ctrlKey && !e.metaKey) {
                    this.appState.selectionBox.start = {
                        x: e.clientX,
                        y: e.clientY
                    };
                    this.appState.selectionBox.end = {
                        x: e.clientX,
                        y: e.clientY
                    };
                }
            }

            handleCanvasMouseMove(e) {
                if (!this.appState.isDragging) return;

                // Update selection box
                if (this.appState.activeTool === 'select' && !e.ctrlKey && !e.metaKey) {
                    this.appState.selectionBox.end = {
                        x: e.clientX,
                        y: e.clientY
                    };
                    // Here you would update the visual selection box
                }
            }

            handleCanvasMouseUp(e) {
                if (!this.appState.isDragging) return;
                this.appState.isDragging = false;

                // Handle selection box
                if (this.appState.activeTool === 'select' && !e.ctrlKey && !e.metaKey) {
                    // Here you would process the selection box area
                    // For now, we'll just clear it
                    this.appState.selectionBox.start = { x: 0, y: 0 };
                    this.appState.selectionBox.end = { x: 0, y: 0 };
                }
            }

            handleCanvasClick(e) {
                if (e.button !== 0) return; // Only left mouse button

                // Don't process clicks if we're in the middle of a transform
                if (this.appState.activeTool === 'sculpt' ||
                    this.sceneManager.transformControls.dragging) {
                    return;
                }

                // Convert mouse position to normalized device coordinates
                this.sceneManager.mouse.x = (e.clientX / this.elements.canvas.clientWidth) * 2 - 1;
                this.sceneManager.mouse.y = -(e.clientY / this.elements.canvas.clientHeight) * 2 + 1;

                // Update the raycaster
                this.sceneManager.raycaster.setFromCamera(this.sceneManager.mouse, this.sceneManager.camera);

                // Calculate objects intersecting the picking ray
                const intersects = this.sceneManager.raycaster.intersectObjects(this.sceneManager.scene.children, true);

                if (intersects.length > 0) {
                    const object = intersects[0].object;
                    // Traverse up in case we hit a child of a group
                    const selectedObject = object.userData.id ? object : this.findParentWithId(object);

                    if (selectedObject && selectedObject.userData.id) {
                        const objectId = selectedObject.userData.id;
                        const multiSelect = e.ctrlKey || e.metaKey;

                        this.selectObjectInScene(objectId, multiSelect);

                        // Update transform controls based on current tool
                        if (this.appState.activeTool !== 'select') {
                            this.sceneManager.transformControls.setMode(this.appState.activeTool);
                            this.sceneManager.transformControls.attach(selectedObject);
                        }
                    }
                } else {
                    // Clicked on empty space - clear selection if not multi-select
                    if (!e.ctrlKey && !e.metaKey) {
                        this.appState.clearSelection();
                        this.sceneManager.clearSelection();
                        this.updateUI();
                    }
                }
            }

            // Helper method to find parent with ID
            findParentWithId(object) {
                let current = object;
                while (current.parent) {
                    if (current.parent.userData && current.parent.userData.id) {
                        return current.parent;
                    }
                    current = current.parent;
                }
                return null;
            }

            handleTransformInputChange() {
                const selectedObjects = this.appState.getSelectedObjects();
                if (selectedObjects.length === 0) return;

                const inputs = this.elements.transformValues.querySelectorAll('input');
                const x = parseFloat(inputs[0].value) || 0;
                const y = parseFloat(inputs[1].value) || 0;
                const z = parseFloat(inputs[2].value) || 0;

                selectedObjects.forEach(obj => {
                    const threeObj = this.sceneManager.getObject(obj.id);
                    if (!threeObj) return;

                    if (this.appState.transformMode === 'location') {
                        threeObj.position.set(x, y, z);
                    } else if (this.appState.transformMode === 'rotation') {
                        threeObj.rotation.set(
                            THREE.MathUtils.degToRad(x),
                            THREE.MathUtils.degToRad(y),
                            THREE.MathUtils.degToRad(z)
                        );
                    } else if (this.appState.transformMode === 'scale') {
                        threeObj.scale.set(x, y, z);
                    }
                });

                this.sceneManager.transformControls.update();
                this.appState.saveHistory(); // Save state after transform
            }

            selectObjectInScene(objectId, multiSelect = false) {
                if (!multiSelect) {
                    this.appState.clearSelection();
                    this.sceneManager.clearSelection();
                }

                this.appState.selectObject(objectId, multiSelect);
                const threeObj = this.sceneManager.getObject(objectId);

                if (threeObj) {
                    if (this.appState.activeTool === 'select') {
                        this.sceneManager.transformControls.detach();
                        this.sceneManager.transformControls.visible = false;
                    } else {
                        this.sceneManager.transformControls.attach(threeObj);
                        this.sceneManager.transformControls.visible = true;
                    }

                    // Update selection box
                    this.sceneManager.selectionBox.setFromObject(threeObj);
                    this.sceneManager.selectionBox.visible = true;
                }
                this.appState.saveHistory();
                this.updateUI();
            }

            createObject(type) {
                const objectData = {
                    id: this.appState.generateId(),
                    type: type,
                    name: `${type}_${this.appState.lastObjectId}`,
                    color: '#808080',
                    roughness: 0.5,
                    metalness: 0,
                    position: { x: 0, y: 0, z: 0 },
                    rotation: { x: 0, y: 0, z: 0 },
                    scale: { x: 1, y: 1, z: 1 }
                };

                // Add to app state first
                this.appState.addObject(objectData);

                // Then add to Three.js scene
                const threeObjWrapper = this.sceneManager.addObject(objectData);
                if (!threeObjWrapper) {
                    console.error('Failed to create object');
                    return;
                }

                // Select the new object
                this.selectObjectInScene(objectData.id);
                this.updateUI();
                this.appState.saveHistory();
                this.showNotification(`${type.charAt(0).toUpperCase() + type.slice(1)} created`, 'success');
            }

            deleteSelectedObjects() {
                const selectedObjects = this.appState.getSelectedObjects();
                if (selectedObjects.length === 0) {
                    this.showNotification('No objects selected', 'warning');
                    return;
                }

                selectedObjects.forEach(obj => {
                    this.appState.removeObject(obj.id);
                    this.sceneManager.removeObject(obj.id);
                });
                this.appState.saveHistory();
                this.updateUI();
                this.showNotification(`${selectedObjects.length} object(s) deleted`, 'success');
            }

            selectAllObjects() {
                this.appState.sceneObjects.forEach(obj => {
                    this.appState.selectObject(obj.id, true);
                });

                if (this.appState.sceneObjects.length > 0) {
                    this.sceneManager.selectObject(this.appState.sceneObjects[0].id);
                }

                this.updateUI();
            }

            groupSelectedObjects() {
                const selectedObjects = this.appState.getSelectedObjects();
                if (selectedObjects.length < 2) {
                    this.showNotification('Select at least 2 objects to group', 'warning');
                    return;
                }

                const objectIds = selectedObjects.map(obj => obj.id);
                this.appState.groupObjects(objectIds);
                this.showNotification('Objects grouped', 'success');
            }

            ungroupSelectedObjects() {
                const selectedObjects = this.appState.getSelectedObjects();
                if (selectedObjects.length === 0) {
                    this.showNotification('No objects selected', 'warning');
                    return;
                }

                // For simplicity, we'll just ungroup the first selected group
                const group = this.appState.groups.find(g =>
                    selectedObjects.some(obj => obj.id === g.id)
                );

                if (group) {
                    this.appState.ungroupObjects(group.id);
                    this.showNotification('Group ungrouped', 'success');
                } else {
                    this.showNotification('Selected object is not a group', 'warning');
                }
            }

            toggleSelectedObjectsVisibility() {
                const selectedObjects = this.appState.getSelectedObjects();
                if (selectedObjects.length === 0) {
                    this.showNotification('No objects selected', 'warning');
                    return;
                }

                selectedObjects.forEach(obj => {
                    this.appState.toggleObjectVisibility(obj.id);
                    const threeObj = this.sceneManager.getObject(obj.id);
                    if (threeObj) {
                        threeObj.visible = !this.appState.hiddenObjects.includes(obj.id);
                        if (threeObj.userData.helper) {
                            threeObj.userData.helper.visible = !this.appState.hiddenObjects.includes(obj.id);
                        }
                    }
                });

                this.showNotification('Visibility toggled', 'success');
            }

            toggleSelectedObjectsFreeze() {
                const selectedObjects = this.appState.getSelectedObjects();
                if (selectedObjects.length === 0) {
                    this.showNotification('No objects selected', 'warning');
                    return;
                }

                selectedObjects.forEach(obj => {
                    this.appState.toggleObjectFreeze(obj.id);
                    // In a real implementation, you would disable transformation controls for frozen objects
                });

                this.showNotification('Freeze toggled', 'success');
            }

            newProject() {
                if (confirm('Are you sure you want to start a new project? All unsaved changes will be lost.')) {
                    this.appState.resetState();
                    this.sceneManager.scene.children.forEach(child => {
                        if (child !== this.sceneManager.camera &&
                            child !== this.sceneManager.controls &&
                            child !== this.sceneManager.gridHelper &&
                            child !== this.sceneManager.axesHelper &&
                            child !== this.sceneManager.transformControls) {
                            this.sceneManager.scene.remove(child);
                        }
                    });
                    this.updateUI();
                    this.showNotification('New project created', 'success');
                }
            }

            /* exportScene() {
                 const exporter = new THREE.GLTFExporter();
                 exporter.parse(
                     this.sceneManager.scene,
                     (gltf) => {
                         const blob = new Blob([JSON.stringify(gltf)], { type: 'application/json' });
                         const url = URL.createObjectURL(blob);
                         const a = document.createElement('a');
                         a.href = url;
                         a.download = 'scene.gltf';
                         document.body.appendChild(a);
                         a.click();
                         document.body.removeChild(a);
                         URL.revokeObjectURL(url);
                         this.showNotification('Scene exported successfully', 'success');
                     },
                     (error) => {
                         console.error('Export error:', error);
                         this.showNotification('Export failed', 'error');
                     }
                 );
             }*/

            applyTextureToSelected(file) {
                const selectedObjects = this.appState.getSelectedObjects();
                if (selectedObjects.length === 0) {
                    this.showNotification('No objects selected', 'warning');
                    return;
                }

                const textureType = this.currentTextureType;
                const textureName = file.name;
                const textureUrl = URL.createObjectURL(file);

                // Update UI
                const mapNameElement = document.getElementById(`${textureType}-map-name`);
                if (mapNameElement) {
                    mapNameElement.textContent = textureName;
                }

                // Apply texture to selected objects
                selectedObjects.forEach(obj => {
                    const threeObj = this.sceneManager.getObject(obj.id);
                    if (threeObj && threeObj.material) {
                        this.sceneManager.applyTexture(threeObj, textureType, textureUrl);
                    }
                });

                this.showNotification(`${textureType} texture applied`, 'success');
            }

            clearTexture(textureType) {
                const selectedObjects = this.appState.getSelectedObjects();
                if (selectedObjects.length === 0) {
                    this.showNotification('No objects selected', 'warning');
                    return;
                }

                // Update UI
                const mapNameElement = document.getElementById(`${textureType}-map-name`);
                if (mapNameElement) {
                    mapNameElement.textContent = 'None';
                }

                // Clear texture from selected objects
                selectedObjects.forEach(obj => {
                    const threeObj = this.sceneManager.getObject(obj.id);
                    if (threeObj && threeObj.material) {
                        switch (textureType) {
                            case 'diffuse':
                                threeObj.material.map = null;
                                break;
                            case 'normal':
                                threeObj.material.normalMap = null;
                                break;
                            case 'roughness':
                                threeObj.material.roughnessMap = null;
                                break;
                        }
                        threeObj.material.needsUpdate = true;
                    }
                });

                this.showNotification(`${textureType} texture cleared`, 'success');
            }

            showNotification(message, type = 'info') {
                const notification = this.elements.notification;
                const notificationMessage = this.elements.notificationMessage;

                notification.className = `notification ${type}`;
                notificationMessage.textContent = message;
                notification.classList.add('show');

                setTimeout(() => {
                    notification.classList.remove('show');
                }, 3000);
            }

            updateScene() {
                // Remove all objects from Three.js scene that aren't in app state
                const sceneObjectIds = this.appState.sceneObjects.map(obj => obj.id);
                this.sceneManager.scene.children.forEach(child => {
                    if (child.userData && child.userData.id && !sceneObjectIds.includes(child.userData.id)) {
                        this.sceneManager.scene.remove(child);
                        if (child.userData.helper) {
                            this.sceneManager.scene.remove(child.userData.helper);
                        }
                    }
                });

                // Add any objects from app state that aren't in the scene
                this.appState.sceneObjects.forEach(obj => {
                    if (!this.sceneManager.getObject(obj.id)) {
                        this.sceneManager.addObject(obj);
                    }
                });

                // Update selection
                if (this.appState.selectedObjects.length > 0) {
                    this.sceneManager.selectObject(this.appState.selectedObjects[0]);
                } else {
                    this.sceneManager.clearSelection();
                }

                this.updateUI();
            }
        }

        // ==============================================
        // APPLICATION INITIALIZATION
        // ==============================================
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize Three.js scene
            const canvas = document.getElementById('three-canvas');
            const sceneManager = new SceneManager(canvas);

            // Initialize application state
            const appState = new AppState();
            appState.sceneManager = sceneManager;
            sceneManager.appState = appState;

            // Initialize UI manager
            const uiManager = new UIManager(appState, sceneManager);
            window.sceneManager = sceneManager;
            window.appState = appState;
            window.uiManager = uiManager;

            // Start animation loop
            function animate() {
                requestAnimationFrame(animate);

                const now = performance.now();
                const deltaTime = (now - sceneManager.lastFrameTime) / 1000;
                sceneManager.lastFrameTime = now;

                // Update performance stats
                appState.updatePerformance(deltaTime);

                // Update animation
                appState.updateAnimation(deltaTime);

                // Update UI
                uiManager.updateUI();

                // Render scene
                sceneManager.controls.update();
                sceneManager.renderer.render(sceneManager.scene, sceneManager.camera);
            }

            animate();

            // Handle window resize
            window.addEventListener('resize', () => {
                sceneManager.resize();
            });
        });
    </script>
    <!-- At the bottom of the body -->
    <script defer src="https://cdnjs.cloudflare.com/ajax/libs/spectrum/1.8.1/spectrum.min.js"></script>
    <script defer src="https://unpkg.com/vanilla-picker@2"></script>
</body>

</html>